"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/algoliasearch";
exports.ids = ["vendor-chunks/algoliasearch"];
exports.modules = {

/***/ "(ssr)/./node_modules/algoliasearch/dist/algoliasearch-lite.esm.browser.js":
/*!***************************************************************************!*\
  !*** ./node_modules/algoliasearch/dist/algoliasearch-lite.esm.browser.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction createBrowserLocalStorageCache(options) {\r\n    const namespaceKey = `algoliasearch-client-js-${options.key}`;\r\n    // eslint-disable-next-line functional/no-let\r\n    let storage;\r\n    const getStorage = () => {\r\n        if (storage === undefined) {\r\n            storage = options.localStorage || window.localStorage;\r\n        }\r\n        return storage;\r\n    };\r\n    const getNamespace = () => {\r\n        return JSON.parse(getStorage().getItem(namespaceKey) || '{}');\r\n    };\r\n    const setNamespace = (namespace) => {\r\n        getStorage().setItem(namespaceKey, JSON.stringify(namespace));\r\n    };\r\n    const removeOutdatedCacheItems = () => {\r\n        const timeToLive = options.timeToLive ? options.timeToLive * 1000 : null;\r\n        const namespace = getNamespace();\r\n        const filteredNamespaceWithoutOldFormattedCacheItems = Object.fromEntries(Object.entries(namespace).filter(([, cacheItem]) => {\r\n            return cacheItem.timestamp !== undefined;\r\n        }));\r\n        setNamespace(filteredNamespaceWithoutOldFormattedCacheItems);\r\n        if (!timeToLive)\r\n            return;\r\n        const filteredNamespaceWithoutExpiredItems = Object.fromEntries(Object.entries(filteredNamespaceWithoutOldFormattedCacheItems).filter(([, cacheItem]) => {\r\n            const currentTimestamp = new Date().getTime();\r\n            const isExpired = cacheItem.timestamp + timeToLive < currentTimestamp;\r\n            return !isExpired;\r\n        }));\r\n        setNamespace(filteredNamespaceWithoutExpiredItems);\r\n    };\r\n    return {\r\n        get(key, defaultValue, events = {\r\n            miss: () => Promise.resolve(),\r\n        }) {\r\n            return Promise.resolve()\r\n                .then(() => {\r\n                removeOutdatedCacheItems();\r\n                const keyAsString = JSON.stringify(key);\r\n                return getNamespace()[keyAsString];\r\n            })\r\n                .then(value => {\r\n                return Promise.all([value ? value.value : defaultValue(), value !== undefined]);\r\n            })\r\n                .then(([value, exists]) => {\r\n                return Promise.all([value, exists || events.miss(value)]);\r\n            })\r\n                .then(([value]) => value);\r\n        },\r\n        set(key, value) {\r\n            return Promise.resolve().then(() => {\r\n                const namespace = getNamespace();\r\n                // eslint-disable-next-line functional/immutable-data\r\n                namespace[JSON.stringify(key)] = {\r\n                    timestamp: new Date().getTime(),\r\n                    value,\r\n                };\r\n                getStorage().setItem(namespaceKey, JSON.stringify(namespace));\r\n                return value;\r\n            });\r\n        },\r\n        delete(key) {\r\n            return Promise.resolve().then(() => {\r\n                const namespace = getNamespace();\r\n                // eslint-disable-next-line functional/immutable-data\r\n                delete namespace[JSON.stringify(key)];\r\n                getStorage().setItem(namespaceKey, JSON.stringify(namespace));\r\n            });\r\n        },\r\n        clear() {\r\n            return Promise.resolve().then(() => {\r\n                getStorage().removeItem(namespaceKey);\r\n            });\r\n        },\r\n    };\r\n}\n\n// @todo Add logger on options to debug when caches go wrong.\r\nfunction createFallbackableCache(options) {\r\n    const caches = [...options.caches];\r\n    const current = caches.shift(); // eslint-disable-line functional/immutable-data\r\n    if (current === undefined) {\r\n        return createNullCache();\r\n    }\r\n    return {\r\n        get(key, defaultValue, events = {\r\n            miss: () => Promise.resolve(),\r\n        }) {\r\n            return current.get(key, defaultValue, events).catch(() => {\r\n                return createFallbackableCache({ caches }).get(key, defaultValue, events);\r\n            });\r\n        },\r\n        set(key, value) {\r\n            return current.set(key, value).catch(() => {\r\n                return createFallbackableCache({ caches }).set(key, value);\r\n            });\r\n        },\r\n        delete(key) {\r\n            return current.delete(key).catch(() => {\r\n                return createFallbackableCache({ caches }).delete(key);\r\n            });\r\n        },\r\n        clear() {\r\n            return current.clear().catch(() => {\r\n                return createFallbackableCache({ caches }).clear();\r\n            });\r\n        },\r\n    };\r\n}\n\nfunction createNullCache() {\r\n    return {\r\n        get(_key, defaultValue, events = {\r\n            miss: () => Promise.resolve(),\r\n        }) {\r\n            const value = defaultValue();\r\n            return value\r\n                .then(result => Promise.all([result, events.miss(result)]))\r\n                .then(([result]) => result);\r\n        },\r\n        set(_key, value) {\r\n            return Promise.resolve(value);\r\n        },\r\n        delete(_key) {\r\n            return Promise.resolve();\r\n        },\r\n        clear() {\r\n            return Promise.resolve();\r\n        },\r\n    };\r\n}\n\nfunction createInMemoryCache(options = { serializable: true }) {\r\n    // eslint-disable-next-line functional/no-let\r\n    let cache = {};\r\n    return {\r\n        get(key, defaultValue, events = {\r\n            miss: () => Promise.resolve(),\r\n        }) {\r\n            const keyAsString = JSON.stringify(key);\r\n            if (keyAsString in cache) {\r\n                return Promise.resolve(options.serializable ? JSON.parse(cache[keyAsString]) : cache[keyAsString]);\r\n            }\r\n            const promise = defaultValue();\r\n            const miss = (events && events.miss) || (() => Promise.resolve());\r\n            return promise.then((value) => miss(value)).then(() => promise);\r\n        },\r\n        set(key, value) {\r\n            // eslint-disable-next-line functional/immutable-data\r\n            cache[JSON.stringify(key)] = options.serializable ? JSON.stringify(value) : value;\r\n            return Promise.resolve(value);\r\n        },\r\n        delete(key) {\r\n            // eslint-disable-next-line functional/immutable-data\r\n            delete cache[JSON.stringify(key)];\r\n            return Promise.resolve();\r\n        },\r\n        clear() {\r\n            cache = {};\r\n            return Promise.resolve();\r\n        },\r\n    };\r\n}\n\nfunction createAuth(authMode, appId, apiKey) {\r\n    const credentials = {\r\n        'x-algolia-api-key': apiKey,\r\n        'x-algolia-application-id': appId,\r\n    };\r\n    return {\r\n        headers() {\r\n            return authMode === AuthMode.WithinHeaders ? credentials : {};\r\n        },\r\n        queryParameters() {\r\n            return authMode === AuthMode.WithinQueryParameters ? credentials : {};\r\n        },\r\n    };\r\n}\n\n// eslint-disable-next-line functional/prefer-readonly-type\r\nfunction shuffle(array) {\r\n    let c = array.length - 1; // eslint-disable-line functional/no-let\r\n    // eslint-disable-next-line functional/no-loop-statement\r\n    for (c; c > 0; c--) {\r\n        const b = Math.floor(Math.random() * (c + 1));\r\n        const a = array[c];\r\n        array[c] = array[b]; // eslint-disable-line functional/immutable-data, no-param-reassign\r\n        array[b] = a; // eslint-disable-line functional/immutable-data, no-param-reassign\r\n    }\r\n    return array;\r\n}\r\nfunction addMethods(base, methods) {\r\n    if (!methods) {\r\n        return base;\r\n    }\r\n    Object.keys(methods).forEach(key => {\r\n        // eslint-disable-next-line functional/immutable-data, no-param-reassign\r\n        base[key] = methods[key](base);\r\n    });\r\n    return base;\r\n}\r\nfunction encode(format, ...args) {\r\n    // eslint-disable-next-line functional/no-let\r\n    let i = 0;\r\n    return format.replace(/%s/g, () => encodeURIComponent(args[i++]));\r\n}\n\nconst version = '4.23.3';\n\nconst AuthMode = {\r\n    /**\r\n     * If auth credentials should be in query parameters.\r\n     */\r\n    WithinQueryParameters: 0,\r\n    /**\r\n     * If auth credentials should be in headers.\r\n     */\r\n    WithinHeaders: 1,\r\n};\n\nfunction createMappedRequestOptions(requestOptions, timeout) {\r\n    const options = requestOptions || {};\r\n    const data = options.data || {};\r\n    Object.keys(options).forEach(key => {\r\n        if (['timeout', 'headers', 'queryParameters', 'data', 'cacheable'].indexOf(key) === -1) {\r\n            data[key] = options[key]; // eslint-disable-line functional/immutable-data\r\n        }\r\n    });\r\n    return {\r\n        data: Object.entries(data).length > 0 ? data : undefined,\r\n        timeout: options.timeout || timeout,\r\n        headers: options.headers || {},\r\n        queryParameters: options.queryParameters || {},\r\n        cacheable: options.cacheable,\r\n    };\r\n}\n\nconst CallEnum = {\r\n    /**\r\n     * If the host is read only.\r\n     */\r\n    Read: 1,\r\n    /**\r\n     * If the host is write only.\r\n     */\r\n    Write: 2,\r\n    /**\r\n     * If the host is both read and write.\r\n     */\r\n    Any: 3,\r\n};\n\nconst HostStatusEnum = {\r\n    Up: 1,\r\n    Down: 2,\r\n    Timeouted: 3,\r\n};\n\n// By default, API Clients at Algolia have expiration delay\r\n// of 5 mins. In the JavaScript client, we have 2 mins.\r\nconst EXPIRATION_DELAY = 2 * 60 * 1000;\r\nfunction createStatefulHost(host, status = HostStatusEnum.Up) {\r\n    return {\r\n        ...host,\r\n        status,\r\n        lastUpdate: Date.now(),\r\n    };\r\n}\r\nfunction isStatefulHostUp(host) {\r\n    return host.status === HostStatusEnum.Up || Date.now() - host.lastUpdate > EXPIRATION_DELAY;\r\n}\r\nfunction isStatefulHostTimeouted(host) {\r\n    return (host.status === HostStatusEnum.Timeouted && Date.now() - host.lastUpdate <= EXPIRATION_DELAY);\r\n}\n\nfunction createStatelessHost(options) {\r\n    if (typeof options === 'string') {\r\n        return {\r\n            protocol: 'https',\r\n            url: options,\r\n            accept: CallEnum.Any,\r\n        };\r\n    }\r\n    return {\r\n        protocol: options.protocol || 'https',\r\n        url: options.url,\r\n        accept: options.accept || CallEnum.Any,\r\n    };\r\n}\n\nconst MethodEnum = {\r\n    Delete: 'DELETE',\r\n    Get: 'GET',\r\n    Post: 'POST',\r\n    Put: 'PUT',\r\n};\n\nfunction createRetryableOptions(hostsCache, statelessHosts) {\r\n    return Promise.all(statelessHosts.map(statelessHost => {\r\n        return hostsCache.get(statelessHost, () => {\r\n            return Promise.resolve(createStatefulHost(statelessHost));\r\n        });\r\n    })).then(statefulHosts => {\r\n        const hostsUp = statefulHosts.filter(host => isStatefulHostUp(host));\r\n        const hostsTimeouted = statefulHosts.filter(host => isStatefulHostTimeouted(host));\r\n        /**\r\n         * Note, we put the hosts that previously timeouted on the end of the list.\r\n         */\r\n        const hostsAvailable = [...hostsUp, ...hostsTimeouted];\r\n        const statelessHostsAvailable = hostsAvailable.length > 0\r\n            ? hostsAvailable.map(host => createStatelessHost(host))\r\n            : statelessHosts;\r\n        return {\r\n            getTimeout(timeoutsCount, baseTimeout) {\r\n                /**\r\n                 * Imagine that you have 4 hosts, if timeouts will increase\r\n                 * on the following way: 1 (timeouted) > 4 (timeouted) > 5 (200)\r\n                 *\r\n                 * Note that, the very next request, we start from the previous timeout\r\n                 *\r\n                 *  5 (timeouted) > 6 (timeouted) > 7 ...\r\n                 *\r\n                 * This strategy may need to be reviewed, but is the strategy on the our\r\n                 * current v3 version.\r\n                 */\r\n                const timeoutMultiplier = hostsTimeouted.length === 0 && timeoutsCount === 0\r\n                    ? 1\r\n                    : hostsTimeouted.length + 3 + timeoutsCount;\r\n                return timeoutMultiplier * baseTimeout;\r\n            },\r\n            statelessHosts: statelessHostsAvailable,\r\n        };\r\n    });\r\n}\n\nconst isNetworkError = ({ isTimedOut, status }) => {\r\n    return !isTimedOut && ~~status === 0;\r\n};\r\nconst isRetryable = (response) => {\r\n    const status = response.status;\r\n    const isTimedOut = response.isTimedOut;\r\n    return (isTimedOut || isNetworkError(response) || (~~(status / 100) !== 2 && ~~(status / 100) !== 4));\r\n};\r\nconst isSuccess = ({ status }) => {\r\n    return ~~(status / 100) === 2;\r\n};\r\nconst retryDecision = (response, outcomes) => {\r\n    if (isRetryable(response)) {\r\n        return outcomes.onRetry(response);\r\n    }\r\n    if (isSuccess(response)) {\r\n        return outcomes.onSuccess(response);\r\n    }\r\n    return outcomes.onFail(response);\r\n};\n\nfunction retryableRequest(transporter, statelessHosts, request, requestOptions) {\r\n    const stackTrace = []; // eslint-disable-line functional/prefer-readonly-type\r\n    /**\r\n     * First we prepare the payload that do not depend from hosts.\r\n     */\r\n    const data = serializeData(request, requestOptions);\r\n    const headers = serializeHeaders(transporter, requestOptions);\r\n    const method = request.method;\r\n    // On `GET`, the data is proxied to query parameters.\r\n    const dataQueryParameters = request.method !== MethodEnum.Get\r\n        ? {}\r\n        : {\r\n            ...request.data,\r\n            ...requestOptions.data,\r\n        };\r\n    const queryParameters = {\r\n        'x-algolia-agent': transporter.userAgent.value,\r\n        ...transporter.queryParameters,\r\n        ...dataQueryParameters,\r\n        ...requestOptions.queryParameters,\r\n    };\r\n    let timeoutsCount = 0; // eslint-disable-line functional/no-let\r\n    const retry = (hosts, // eslint-disable-line functional/prefer-readonly-type\r\n    getTimeout) => {\r\n        /**\r\n         * We iterate on each host, until there is no host left.\r\n         */\r\n        const host = hosts.pop(); // eslint-disable-line functional/immutable-data\r\n        if (host === undefined) {\r\n            throw createRetryError(stackTraceWithoutCredentials(stackTrace));\r\n        }\r\n        const payload = {\r\n            data,\r\n            headers,\r\n            method,\r\n            url: serializeUrl(host, request.path, queryParameters),\r\n            connectTimeout: getTimeout(timeoutsCount, transporter.timeouts.connect),\r\n            responseTimeout: getTimeout(timeoutsCount, requestOptions.timeout),\r\n        };\r\n        /**\r\n         * The stackFrame is pushed to the stackTrace so we\r\n         * can have information about onRetry and onFailure\r\n         * decisions.\r\n         */\r\n        const pushToStackTrace = (response) => {\r\n            const stackFrame = {\r\n                request: payload,\r\n                response,\r\n                host,\r\n                triesLeft: hosts.length,\r\n            };\r\n            // eslint-disable-next-line functional/immutable-data\r\n            stackTrace.push(stackFrame);\r\n            return stackFrame;\r\n        };\r\n        const decisions = {\r\n            onSuccess: response => deserializeSuccess(response),\r\n            onRetry(response) {\r\n                const stackFrame = pushToStackTrace(response);\r\n                /**\r\n                 * If response is a timeout, we increaset the number of\r\n                 * timeouts so we can increase the timeout later.\r\n                 */\r\n                if (response.isTimedOut) {\r\n                    timeoutsCount++;\r\n                }\r\n                return Promise.all([\r\n                    /**\r\n                     * Failures are individually send the logger, allowing\r\n                     * the end user to debug / store stack frames even\r\n                     * when a retry error does not happen.\r\n                     */\r\n                    transporter.logger.info('Retryable failure', stackFrameWithoutCredentials(stackFrame)),\r\n                    /**\r\n                     * We also store the state of the host in failure cases. If the host, is\r\n                     * down it will remain down for the next 2 minutes. In a timeout situation,\r\n                     * this host will be added end of the list of hosts on the next request.\r\n                     */\r\n                    transporter.hostsCache.set(host, createStatefulHost(host, response.isTimedOut ? HostStatusEnum.Timeouted : HostStatusEnum.Down)),\r\n                ]).then(() => retry(hosts, getTimeout));\r\n            },\r\n            onFail(response) {\r\n                pushToStackTrace(response);\r\n                throw deserializeFailure(response, stackTraceWithoutCredentials(stackTrace));\r\n            },\r\n        };\r\n        return transporter.requester.send(payload).then(response => {\r\n            return retryDecision(response, decisions);\r\n        });\r\n    };\r\n    /**\r\n     * Finally, for each retryable host perform request until we got a non\r\n     * retryable response. Some notes here:\r\n     *\r\n     * 1. The reverse here is applied so we can apply a `pop` later on => more performant.\r\n     * 2. We also get from the retryable options a timeout multiplier that is tailored\r\n     * for the current context.\r\n     */\r\n    return createRetryableOptions(transporter.hostsCache, statelessHosts).then(options => {\r\n        return retry([...options.statelessHosts].reverse(), options.getTimeout);\r\n    });\r\n}\n\nfunction createTransporter(options) {\r\n    const { hostsCache, logger, requester, requestsCache, responsesCache, timeouts, userAgent, hosts, queryParameters, headers, } = options;\r\n    const transporter = {\r\n        hostsCache,\r\n        logger,\r\n        requester,\r\n        requestsCache,\r\n        responsesCache,\r\n        timeouts,\r\n        userAgent,\r\n        headers,\r\n        queryParameters,\r\n        hosts: hosts.map(host => createStatelessHost(host)),\r\n        read(request, requestOptions) {\r\n            /**\r\n             * First, we compute the user request options. Now, keep in mind,\r\n             * that using request options the user is able to modified the intire\r\n             * payload of the request. Such as headers, query parameters, and others.\r\n             */\r\n            const mappedRequestOptions = createMappedRequestOptions(requestOptions, transporter.timeouts.read);\r\n            const createRetryableRequest = () => {\r\n                /**\r\n                 * Then, we prepare a function factory that contains the construction of\r\n                 * the retryable request. At this point, we may *not* perform the actual\r\n                 * request. But we want to have the function factory ready.\r\n                 */\r\n                return retryableRequest(transporter, transporter.hosts.filter(host => (host.accept & CallEnum.Read) !== 0), request, mappedRequestOptions);\r\n            };\r\n            /**\r\n             * Once we have the function factory ready, we need to determine of the\r\n             * request is \"cacheable\" - should be cached. Note that, once again,\r\n             * the user can force this option.\r\n             */\r\n            const cacheable = mappedRequestOptions.cacheable !== undefined\r\n                ? mappedRequestOptions.cacheable\r\n                : request.cacheable;\r\n            /**\r\n             * If is not \"cacheable\", we immediatly trigger the retryable request, no\r\n             * need to check cache implementations.\r\n             */\r\n            if (cacheable !== true) {\r\n                return createRetryableRequest();\r\n            }\r\n            /**\r\n             * If the request is \"cacheable\", we need to first compute the key to ask\r\n             * the cache implementations if this request is on progress or if the\r\n             * response already exists on the cache.\r\n             */\r\n            const key = {\r\n                request,\r\n                mappedRequestOptions,\r\n                transporter: {\r\n                    queryParameters: transporter.queryParameters,\r\n                    headers: transporter.headers,\r\n                },\r\n            };\r\n            /**\r\n             * With the computed key, we first ask the responses cache\r\n             * implemention if this request was been resolved before.\r\n             */\r\n            return transporter.responsesCache.get(key, () => {\r\n                /**\r\n                 * If the request has never resolved before, we actually ask if there\r\n                 * is a current request with the same key on progress.\r\n                 */\r\n                return transporter.requestsCache.get(key, () => {\r\n                    return (transporter.requestsCache\r\n                        /**\r\n                         * Finally, if there is no request in progress with the same key,\r\n                         * this `createRetryableRequest()` will actually trigger the\r\n                         * retryable request.\r\n                         */\r\n                        .set(key, createRetryableRequest())\r\n                        .then(response => Promise.all([transporter.requestsCache.delete(key), response]), err => Promise.all([transporter.requestsCache.delete(key), Promise.reject(err)]))\r\n                        .then(([_, response]) => response));\r\n                });\r\n            }, {\r\n                /**\r\n                 * Of course, once we get this response back from the server, we\r\n                 * tell response cache to actually store the received response\r\n                 * to be used later.\r\n                 */\r\n                miss: response => transporter.responsesCache.set(key, response),\r\n            });\r\n        },\r\n        write(request, requestOptions) {\r\n            /**\r\n             * On write requests, no cache mechanisms are applied, and we\r\n             * proxy the request immediately to the requester.\r\n             */\r\n            return retryableRequest(transporter, transporter.hosts.filter(host => (host.accept & CallEnum.Write) !== 0), request, createMappedRequestOptions(requestOptions, transporter.timeouts.write));\r\n        },\r\n    };\r\n    return transporter;\r\n}\n\nfunction createUserAgent(version) {\r\n    const userAgent = {\r\n        value: `Algolia for JavaScript (${version})`,\r\n        add(options) {\r\n            const addedUserAgent = `; ${options.segment}${options.version !== undefined ? ` (${options.version})` : ''}`;\r\n            if (userAgent.value.indexOf(addedUserAgent) === -1) {\r\n                // eslint-disable-next-line functional/immutable-data\r\n                userAgent.value = `${userAgent.value}${addedUserAgent}`;\r\n            }\r\n            return userAgent;\r\n        },\r\n    };\r\n    return userAgent;\r\n}\n\nfunction deserializeSuccess(response) {\r\n    // eslint-disable-next-line functional/no-try-statement\r\n    try {\r\n        return JSON.parse(response.content);\r\n    }\r\n    catch (e) {\r\n        throw createDeserializationError(e.message, response);\r\n    }\r\n}\r\nfunction deserializeFailure({ content, status }, stackFrame) {\r\n    // eslint-disable-next-line functional/no-let\r\n    let message = content;\r\n    // eslint-disable-next-line functional/no-try-statement\r\n    try {\r\n        message = JSON.parse(content).message;\r\n    }\r\n    catch (e) {\r\n        // ..\r\n    }\r\n    return createApiError(message, status, stackFrame);\r\n}\n\nfunction serializeUrl(host, path, queryParameters) {\r\n    const queryParametersAsString = serializeQueryParameters(queryParameters);\r\n    // eslint-disable-next-line functional/no-let\r\n    let url = `${host.protocol}://${host.url}/${path.charAt(0) === '/' ? path.substr(1) : path}`;\r\n    if (queryParametersAsString.length) {\r\n        url += `?${queryParametersAsString}`;\r\n    }\r\n    return url;\r\n}\r\nfunction serializeQueryParameters(parameters) {\r\n    const isObjectOrArray = (value) => Object.prototype.toString.call(value) === '[object Object]' ||\r\n        Object.prototype.toString.call(value) === '[object Array]';\r\n    return Object.keys(parameters)\r\n        .map(key => encode('%s=%s', key, isObjectOrArray(parameters[key]) ? JSON.stringify(parameters[key]) : parameters[key]))\r\n        .join('&');\r\n}\r\nfunction serializeData(request, requestOptions) {\r\n    if (request.method === MethodEnum.Get ||\r\n        (request.data === undefined && requestOptions.data === undefined)) {\r\n        return undefined;\r\n    }\r\n    const data = Array.isArray(request.data)\r\n        ? request.data\r\n        : { ...request.data, ...requestOptions.data };\r\n    return JSON.stringify(data);\r\n}\r\nfunction serializeHeaders(transporter, requestOptions) {\r\n    const headers = {\r\n        ...transporter.headers,\r\n        ...requestOptions.headers,\r\n    };\r\n    const serializedHeaders = {};\r\n    Object.keys(headers).forEach(header => {\r\n        const value = headers[header];\r\n        // @ts-ignore\r\n        // eslint-disable-next-line functional/immutable-data\r\n        serializedHeaders[header.toLowerCase()] = value;\r\n    });\r\n    return serializedHeaders;\r\n}\n\nfunction stackTraceWithoutCredentials(stackTrace) {\r\n    return stackTrace.map(stackFrame => stackFrameWithoutCredentials(stackFrame));\r\n}\r\nfunction stackFrameWithoutCredentials(stackFrame) {\r\n    const modifiedHeaders = stackFrame.request.headers['x-algolia-api-key']\r\n        ? { 'x-algolia-api-key': '*****' }\r\n        : {};\r\n    return {\r\n        ...stackFrame,\r\n        request: {\r\n            ...stackFrame.request,\r\n            headers: {\r\n                ...stackFrame.request.headers,\r\n                ...modifiedHeaders,\r\n            },\r\n        },\r\n    };\r\n}\n\nfunction createApiError(message, status, transporterStackTrace) {\r\n    return {\r\n        name: 'ApiError',\r\n        message,\r\n        status,\r\n        transporterStackTrace,\r\n    };\r\n}\n\nfunction createDeserializationError(message, response) {\r\n    return {\r\n        name: 'DeserializationError',\r\n        message,\r\n        response,\r\n    };\r\n}\n\nfunction createRetryError(transporterStackTrace) {\r\n    return {\r\n        name: 'RetryError',\r\n        message: 'Unreachable hosts - your application id may be incorrect. If the error persists, contact support@algolia.com.',\r\n        transporterStackTrace,\r\n    };\r\n}\n\nconst createSearchClient = options => {\r\n    const appId = options.appId;\r\n    const auth = createAuth(options.authMode !== undefined ? options.authMode : AuthMode.WithinHeaders, appId, options.apiKey);\r\n    const transporter = createTransporter({\r\n        hosts: [\r\n            { url: `${appId}-dsn.algolia.net`, accept: CallEnum.Read },\r\n            { url: `${appId}.algolia.net`, accept: CallEnum.Write },\r\n        ].concat(shuffle([\r\n            { url: `${appId}-1.algolianet.com` },\r\n            { url: `${appId}-2.algolianet.com` },\r\n            { url: `${appId}-3.algolianet.com` },\r\n        ])),\r\n        ...options,\r\n        headers: {\r\n            ...auth.headers(),\r\n            ...{ 'content-type': 'application/x-www-form-urlencoded' },\r\n            ...options.headers,\r\n        },\r\n        queryParameters: {\r\n            ...auth.queryParameters(),\r\n            ...options.queryParameters,\r\n        },\r\n    });\r\n    const base = {\r\n        transporter,\r\n        appId,\r\n        addAlgoliaAgent(segment, version) {\r\n            transporter.userAgent.add({ segment, version });\r\n        },\r\n        clearCache() {\r\n            return Promise.all([\r\n                transporter.requestsCache.clear(),\r\n                transporter.responsesCache.clear(),\r\n            ]).then(() => undefined);\r\n        },\r\n    };\r\n    return addMethods(base, options.methods);\r\n};\n\nconst customRequest = (base) => {\r\n    return (request, requestOptions) => {\r\n        if (request.method === MethodEnum.Get) {\r\n            return base.transporter.read(request, requestOptions);\r\n        }\r\n        return base.transporter.write(request, requestOptions);\r\n    };\r\n};\n\nconst initIndex = (base) => {\r\n    return (indexName, options = {}) => {\r\n        const searchIndex = {\r\n            transporter: base.transporter,\r\n            appId: base.appId,\r\n            indexName,\r\n        };\r\n        return addMethods(searchIndex, options.methods);\r\n    };\r\n};\n\nconst multipleQueries = (base) => {\r\n    return (queries, requestOptions) => {\r\n        const requests = queries.map(query => {\r\n            return {\r\n                ...query,\r\n                params: serializeQueryParameters(query.params || {}),\r\n            };\r\n        });\r\n        return base.transporter.read({\r\n            method: MethodEnum.Post,\r\n            path: '1/indexes/*/queries',\r\n            data: {\r\n                requests,\r\n            },\r\n            cacheable: true,\r\n        }, requestOptions);\r\n    };\r\n};\n\nconst multipleSearchForFacetValues = (base) => {\r\n    return (queries, requestOptions) => {\r\n        return Promise.all(queries.map(query => {\r\n            const { facetName, facetQuery, ...params } = query.params;\r\n            return initIndex(base)(query.indexName, {\r\n                methods: { searchForFacetValues },\r\n            }).searchForFacetValues(facetName, facetQuery, {\r\n                ...requestOptions,\r\n                ...params,\r\n            });\r\n        }));\r\n    };\r\n};\n\nconst findAnswers = (base) => {\r\n    return (query, queryLanguages, requestOptions) => {\r\n        return base.transporter.read({\r\n            method: MethodEnum.Post,\r\n            path: encode('1/answers/%s/prediction', base.indexName),\r\n            data: {\r\n                query,\r\n                queryLanguages,\r\n            },\r\n            cacheable: true,\r\n        }, requestOptions);\r\n    };\r\n};\n\nconst search = (base) => {\r\n    return (query, requestOptions) => {\r\n        return base.transporter.read({\r\n            method: MethodEnum.Post,\r\n            path: encode('1/indexes/%s/query', base.indexName),\r\n            data: {\r\n                query,\r\n            },\r\n            cacheable: true,\r\n        }, requestOptions);\r\n    };\r\n};\n\nconst searchForFacetValues = (base) => {\r\n    return (facetName, facetQuery, requestOptions) => {\r\n        return base.transporter.read({\r\n            method: MethodEnum.Post,\r\n            path: encode('1/indexes/%s/facets/%s/query', base.indexName, facetName),\r\n            data: {\r\n                facetQuery,\r\n            },\r\n            cacheable: true,\r\n        }, requestOptions);\r\n    };\r\n};\n\nconst LogLevelEnum = {\r\n    Debug: 1,\r\n    Info: 2,\r\n    Error: 3,\r\n};\n\n/* eslint no-console: 0 */\r\nfunction createConsoleLogger(logLevel) {\r\n    return {\r\n        debug(message, args) {\r\n            if (LogLevelEnum.Debug >= logLevel) {\r\n                console.debug(message, args);\r\n            }\r\n            return Promise.resolve();\r\n        },\r\n        info(message, args) {\r\n            if (LogLevelEnum.Info >= logLevel) {\r\n                console.info(message, args);\r\n            }\r\n            return Promise.resolve();\r\n        },\r\n        error(message, args) {\r\n            console.error(message, args);\r\n            return Promise.resolve();\r\n        },\r\n    };\r\n}\n\nconst getRecommendations = base => {\r\n    return (queries, requestOptions) => {\r\n        const requests = queries.map(query => ({\r\n            ...query,\r\n            // The `threshold` param is required by the endpoint to make it easier\r\n            // to provide a default value later, so we default it in the client\r\n            // so that users don't have to provide a value.\r\n            threshold: query.threshold || 0,\r\n        }));\r\n        return base.transporter.read({\r\n            method: MethodEnum.Post,\r\n            path: '1/indexes/*/recommendations',\r\n            data: {\r\n                requests,\r\n            },\r\n            cacheable: true,\r\n        }, requestOptions);\r\n    };\r\n};\n\nfunction createBrowserXhrRequester() {\r\n    return {\r\n        send(request) {\r\n            return new Promise((resolve) => {\r\n                const baseRequester = new XMLHttpRequest();\r\n                baseRequester.open(request.method, request.url, true);\r\n                Object.keys(request.headers).forEach(key => baseRequester.setRequestHeader(key, request.headers[key]));\r\n                const createTimeout = (timeout, content) => {\r\n                    return setTimeout(() => {\r\n                        baseRequester.abort();\r\n                        resolve({\r\n                            status: 0,\r\n                            content,\r\n                            isTimedOut: true,\r\n                        });\r\n                    }, timeout * 1000);\r\n                };\r\n                const connectTimeout = createTimeout(request.connectTimeout, 'Connection timeout');\r\n                // eslint-disable-next-line functional/no-let\r\n                let responseTimeout;\r\n                // eslint-disable-next-line functional/immutable-data\r\n                baseRequester.onreadystatechange = () => {\r\n                    if (baseRequester.readyState > baseRequester.OPENED && responseTimeout === undefined) {\r\n                        clearTimeout(connectTimeout);\r\n                        responseTimeout = createTimeout(request.responseTimeout, 'Socket timeout');\r\n                    }\r\n                };\r\n                // eslint-disable-next-line functional/immutable-data\r\n                baseRequester.onerror = () => {\r\n                    // istanbul ignore next\r\n                    if (baseRequester.status === 0) {\r\n                        clearTimeout(connectTimeout);\r\n                        clearTimeout(responseTimeout);\r\n                        resolve({\r\n                            content: baseRequester.responseText || 'Network request failed',\r\n                            status: baseRequester.status,\r\n                            isTimedOut: false,\r\n                        });\r\n                    }\r\n                };\r\n                //  eslint-disable-next-line functional/immutable-data\r\n                baseRequester.onload = () => {\r\n                    clearTimeout(connectTimeout);\r\n                    clearTimeout(responseTimeout);\r\n                    resolve({\r\n                        content: baseRequester.responseText,\r\n                        status: baseRequester.status,\r\n                        isTimedOut: false,\r\n                    });\r\n                };\r\n                baseRequester.send(request.data);\r\n            });\r\n        },\r\n    };\r\n}\n\nfunction algoliasearch(appId, apiKey, options) {\r\n    const commonOptions = {\r\n        appId,\r\n        apiKey,\r\n        timeouts: {\r\n            connect: 1,\r\n            read: 2,\r\n            write: 30,\r\n        },\r\n        requester: createBrowserXhrRequester(),\r\n        logger: createConsoleLogger(LogLevelEnum.Error),\r\n        responsesCache: createInMemoryCache(),\r\n        requestsCache: createInMemoryCache({ serializable: false }),\r\n        hostsCache: createFallbackableCache({\r\n            caches: [\r\n                createBrowserLocalStorageCache({ key: `${version}-${appId}` }),\r\n                createInMemoryCache(),\r\n            ],\r\n        }),\r\n        userAgent: createUserAgent(version).add({\r\n            segment: 'Browser',\r\n            version: 'lite',\r\n        }),\r\n        authMode: AuthMode.WithinQueryParameters,\r\n    };\r\n    return createSearchClient({\r\n        ...commonOptions,\r\n        ...options,\r\n        methods: {\r\n            search: multipleQueries,\r\n            searchForFacetValues: multipleSearchForFacetValues,\r\n            multipleQueries,\r\n            multipleSearchForFacetValues,\r\n            customRequest,\r\n            initIndex: base => (indexName) => {\r\n                return initIndex(base)(indexName, {\r\n                    methods: { search, searchForFacetValues, findAnswers },\r\n                });\r\n            },\r\n            getRecommendations,\r\n        },\r\n    });\r\n}\r\n// eslint-disable-next-line functional/immutable-data\r\nalgoliasearch.version = version;\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (algoliasearch);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWxnb2xpYXNlYXJjaC9kaXN0L2FsZ29saWFzZWFyY2gtbGl0ZS5lc20uYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQSxvREFBb0QsWUFBWTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxpREFBaUQsUUFBUTtBQUN6RCxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RCxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RCxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RCxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSx5Q0FBeUMsb0JBQW9CO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBLDBCQUEwQixvQkFBb0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsWUFBWSxzSEFBc0g7QUFDbEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBLHNDQUFzQyxFQUFFLGdCQUFnQixFQUFFLHFDQUFxQyxnQkFBZ0IsUUFBUTtBQUN2SDtBQUNBO0FBQ0EscUNBQXFDLGdCQUFnQixFQUFFLGVBQWU7QUFDdEU7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlCQUFpQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixjQUFjLEtBQUssU0FBUyxHQUFHLCtDQUErQztBQUMvRjtBQUNBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVEsTUFBTSwwQ0FBMEM7QUFDdEUsY0FBYyxRQUFRLE1BQU0sdUNBQXVDO0FBQ25FO0FBQ0EsY0FBYyxRQUFRLE1BQU0sb0JBQW9CO0FBQ2hELGNBQWMsUUFBUSxNQUFNLG9CQUFvQjtBQUNoRCxjQUFjLFFBQVEsTUFBTSxvQkFBb0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscURBQXFEO0FBQ3RFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msa0JBQWtCO0FBQzFELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1DQUFtQztBQUN2RDtBQUNBLDJCQUEyQixzQkFBc0I7QUFDakQsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxxQkFBcUI7QUFDbEU7QUFDQTtBQUNBLGlEQUFpRCxRQUFRLFFBQVEsR0FBRyxNQUFNLEdBQUc7QUFDN0U7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMkNBQTJDO0FBQzFFLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxhQUFhLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90YWlsd2luZC1uZXh0anMtc3RhcnRlci1ibG9nLy4vbm9kZV9tb2R1bGVzL2FsZ29saWFzZWFyY2gvZGlzdC9hbGdvbGlhc2VhcmNoLWxpdGUuZXNtLmJyb3dzZXIuanM/NzY4NSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBjcmVhdGVCcm93c2VyTG9jYWxTdG9yYWdlQ2FjaGUob3B0aW9ucykge1xyXG4gICAgY29uc3QgbmFtZXNwYWNlS2V5ID0gYGFsZ29saWFzZWFyY2gtY2xpZW50LWpzLSR7b3B0aW9ucy5rZXl9YDtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jdGlvbmFsL25vLWxldFxyXG4gICAgbGV0IHN0b3JhZ2U7XHJcbiAgICBjb25zdCBnZXRTdG9yYWdlID0gKCkgPT4ge1xyXG4gICAgICAgIGlmIChzdG9yYWdlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgc3RvcmFnZSA9IG9wdGlvbnMubG9jYWxTdG9yYWdlIHx8IHdpbmRvdy5sb2NhbFN0b3JhZ2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdG9yYWdlO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGdldE5hbWVzcGFjZSA9ICgpID0+IHtcclxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShnZXRTdG9yYWdlKCkuZ2V0SXRlbShuYW1lc3BhY2VLZXkpIHx8ICd7fScpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHNldE5hbWVzcGFjZSA9IChuYW1lc3BhY2UpID0+IHtcclxuICAgICAgICBnZXRTdG9yYWdlKCkuc2V0SXRlbShuYW1lc3BhY2VLZXksIEpTT04uc3RyaW5naWZ5KG5hbWVzcGFjZSkpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlbW92ZU91dGRhdGVkQ2FjaGVJdGVtcyA9ICgpID0+IHtcclxuICAgICAgICBjb25zdCB0aW1lVG9MaXZlID0gb3B0aW9ucy50aW1lVG9MaXZlID8gb3B0aW9ucy50aW1lVG9MaXZlICogMTAwMCA6IG51bGw7XHJcbiAgICAgICAgY29uc3QgbmFtZXNwYWNlID0gZ2V0TmFtZXNwYWNlKCk7XHJcbiAgICAgICAgY29uc3QgZmlsdGVyZWROYW1lc3BhY2VXaXRob3V0T2xkRm9ybWF0dGVkQ2FjaGVJdGVtcyA9IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhuYW1lc3BhY2UpLmZpbHRlcigoWywgY2FjaGVJdGVtXSkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVJdGVtLnRpbWVzdGFtcCAhPT0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH0pKTtcclxuICAgICAgICBzZXROYW1lc3BhY2UoZmlsdGVyZWROYW1lc3BhY2VXaXRob3V0T2xkRm9ybWF0dGVkQ2FjaGVJdGVtcyk7XHJcbiAgICAgICAgaWYgKCF0aW1lVG9MaXZlKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY29uc3QgZmlsdGVyZWROYW1lc3BhY2VXaXRob3V0RXhwaXJlZEl0ZW1zID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGZpbHRlcmVkTmFtZXNwYWNlV2l0aG91dE9sZEZvcm1hdHRlZENhY2hlSXRlbXMpLmZpbHRlcigoWywgY2FjaGVJdGVtXSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VGltZXN0YW1wID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzRXhwaXJlZCA9IGNhY2hlSXRlbS50aW1lc3RhbXAgKyB0aW1lVG9MaXZlIDwgY3VycmVudFRpbWVzdGFtcDtcclxuICAgICAgICAgICAgcmV0dXJuICFpc0V4cGlyZWQ7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHNldE5hbWVzcGFjZShmaWx0ZXJlZE5hbWVzcGFjZVdpdGhvdXRFeHBpcmVkSXRlbXMpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZ2V0KGtleSwgZGVmYXVsdFZhbHVlLCBldmVudHMgPSB7XHJcbiAgICAgICAgICAgIG1pc3M6ICgpID0+IFByb21pc2UucmVzb2x2ZSgpLFxyXG4gICAgICAgIH0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXHJcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVPdXRkYXRlZENhY2hlSXRlbXMoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGtleUFzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoa2V5KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBnZXROYW1lc3BhY2UoKVtrZXlBc1N0cmluZ107XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAudGhlbih2YWx1ZSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW3ZhbHVlID8gdmFsdWUudmFsdWUgOiBkZWZhdWx0VmFsdWUoKSwgdmFsdWUgIT09IHVuZGVmaW5lZF0pO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKFt2YWx1ZSwgZXhpc3RzXSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFt2YWx1ZSwgZXhpc3RzIHx8IGV2ZW50cy5taXNzKHZhbHVlKV0pO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKFt2YWx1ZV0pID0+IHZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWVzcGFjZSA9IGdldE5hbWVzcGFjZSgpO1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmN0aW9uYWwvaW1tdXRhYmxlLWRhdGFcclxuICAgICAgICAgICAgICAgIG5hbWVzcGFjZVtKU09OLnN0cmluZ2lmeShrZXkpXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGdldFN0b3JhZ2UoKS5zZXRJdGVtKG5hbWVzcGFjZUtleSwgSlNPTi5zdHJpbmdpZnkobmFtZXNwYWNlKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVsZXRlKGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lc3BhY2UgPSBnZXROYW1lc3BhY2UoKTtcclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jdGlvbmFsL2ltbXV0YWJsZS1kYXRhXHJcbiAgICAgICAgICAgICAgICBkZWxldGUgbmFtZXNwYWNlW0pTT04uc3RyaW5naWZ5KGtleSldO1xyXG4gICAgICAgICAgICAgICAgZ2V0U3RvcmFnZSgpLnNldEl0ZW0obmFtZXNwYWNlS2V5LCBKU09OLnN0cmluZ2lmeShuYW1lc3BhY2UpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjbGVhcigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZ2V0U3RvcmFnZSgpLnJlbW92ZUl0ZW0obmFtZXNwYWNlS2V5KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cblxuLy8gQHRvZG8gQWRkIGxvZ2dlciBvbiBvcHRpb25zIHRvIGRlYnVnIHdoZW4gY2FjaGVzIGdvIHdyb25nLlxyXG5mdW5jdGlvbiBjcmVhdGVGYWxsYmFja2FibGVDYWNoZShvcHRpb25zKSB7XHJcbiAgICBjb25zdCBjYWNoZXMgPSBbLi4ub3B0aW9ucy5jYWNoZXNdO1xyXG4gICAgY29uc3QgY3VycmVudCA9IGNhY2hlcy5zaGlmdCgpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmN0aW9uYWwvaW1tdXRhYmxlLWRhdGFcclxuICAgIGlmIChjdXJyZW50ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlTnVsbENhY2hlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGdldChrZXksIGRlZmF1bHRWYWx1ZSwgZXZlbnRzID0ge1xyXG4gICAgICAgICAgICBtaXNzOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoKSxcclxuICAgICAgICB9KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50LmdldChrZXksIGRlZmF1bHRWYWx1ZSwgZXZlbnRzKS5jYXRjaCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlRmFsbGJhY2thYmxlQ2FjaGUoeyBjYWNoZXMgfSkuZ2V0KGtleSwgZGVmYXVsdFZhbHVlLCBldmVudHMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50LnNldChrZXksIHZhbHVlKS5jYXRjaCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlRmFsbGJhY2thYmxlQ2FjaGUoeyBjYWNoZXMgfSkuc2V0KGtleSwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlbGV0ZShrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQuZGVsZXRlKGtleSkuY2F0Y2goKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUZhbGxiYWNrYWJsZUNhY2hlKHsgY2FjaGVzIH0pLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNsZWFyKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gY3VycmVudC5jbGVhcigpLmNhdGNoKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVGYWxsYmFja2FibGVDYWNoZSh7IGNhY2hlcyB9KS5jbGVhcigpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxuXG5mdW5jdGlvbiBjcmVhdGVOdWxsQ2FjaGUoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGdldChfa2V5LCBkZWZhdWx0VmFsdWUsIGV2ZW50cyA9IHtcclxuICAgICAgICAgICAgbWlzczogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCksXHJcbiAgICAgICAgfSkge1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRlZmF1bHRWYWx1ZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWVcclxuICAgICAgICAgICAgICAgIC50aGVuKHJlc3VsdCA9PiBQcm9taXNlLmFsbChbcmVzdWx0LCBldmVudHMubWlzcyhyZXN1bHQpXSkpXHJcbiAgICAgICAgICAgICAgICAudGhlbigoW3Jlc3VsdF0pID0+IHJlc3VsdCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQoX2tleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZWxldGUoX2tleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjbGVhcigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUluTWVtb3J5Q2FjaGUob3B0aW9ucyA9IHsgc2VyaWFsaXphYmxlOiB0cnVlIH0pIHtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jdGlvbmFsL25vLWxldFxyXG4gICAgbGV0IGNhY2hlID0ge307XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGdldChrZXksIGRlZmF1bHRWYWx1ZSwgZXZlbnRzID0ge1xyXG4gICAgICAgICAgICBtaXNzOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoKSxcclxuICAgICAgICB9KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleUFzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoa2V5KTtcclxuICAgICAgICAgICAgaWYgKGtleUFzU3RyaW5nIGluIGNhY2hlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG9wdGlvbnMuc2VyaWFsaXphYmxlID8gSlNPTi5wYXJzZShjYWNoZVtrZXlBc1N0cmluZ10pIDogY2FjaGVba2V5QXNTdHJpbmddKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gZGVmYXVsdFZhbHVlKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1pc3MgPSAoZXZlbnRzICYmIGV2ZW50cy5taXNzKSB8fCAoKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKCh2YWx1ZSkgPT4gbWlzcyh2YWx1ZSkpLnRoZW4oKCkgPT4gcHJvbWlzZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuY3Rpb25hbC9pbW11dGFibGUtZGF0YVxyXG4gICAgICAgICAgICBjYWNoZVtKU09OLnN0cmluZ2lmeShrZXkpXSA9IG9wdGlvbnMuc2VyaWFsaXphYmxlID8gSlNPTi5zdHJpbmdpZnkodmFsdWUpIDogdmFsdWU7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVsZXRlKGtleSkge1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuY3Rpb25hbC9pbW11dGFibGUtZGF0YVxyXG4gICAgICAgICAgICBkZWxldGUgY2FjaGVbSlNPTi5zdHJpbmdpZnkoa2V5KV07XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNsZWFyKCkge1xyXG4gICAgICAgICAgICBjYWNoZSA9IHt9O1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXV0aChhdXRoTW9kZSwgYXBwSWQsIGFwaUtleSkge1xyXG4gICAgY29uc3QgY3JlZGVudGlhbHMgPSB7XHJcbiAgICAgICAgJ3gtYWxnb2xpYS1hcGkta2V5JzogYXBpS2V5LFxyXG4gICAgICAgICd4LWFsZ29saWEtYXBwbGljYXRpb24taWQnOiBhcHBJZCxcclxuICAgIH07XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGhlYWRlcnMoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhdXRoTW9kZSA9PT0gQXV0aE1vZGUuV2l0aGluSGVhZGVycyA/IGNyZWRlbnRpYWxzIDoge307XHJcbiAgICAgICAgfSxcclxuICAgICAgICBxdWVyeVBhcmFtZXRlcnMoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhdXRoTW9kZSA9PT0gQXV0aE1vZGUuV2l0aGluUXVlcnlQYXJhbWV0ZXJzID8gY3JlZGVudGlhbHMgOiB7fTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuY3Rpb25hbC9wcmVmZXItcmVhZG9ubHktdHlwZVxyXG5mdW5jdGlvbiBzaHVmZmxlKGFycmF5KSB7XHJcbiAgICBsZXQgYyA9IGFycmF5Lmxlbmd0aCAtIDE7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZnVuY3Rpb25hbC9uby1sZXRcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jdGlvbmFsL25vLWxvb3Atc3RhdGVtZW50XHJcbiAgICBmb3IgKGM7IGMgPiAwOyBjLS0pIHtcclxuICAgICAgICBjb25zdCBiID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGMgKyAxKSk7XHJcbiAgICAgICAgY29uc3QgYSA9IGFycmF5W2NdO1xyXG4gICAgICAgIGFycmF5W2NdID0gYXJyYXlbYl07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZnVuY3Rpb25hbC9pbW11dGFibGUtZGF0YSwgbm8tcGFyYW0tcmVhc3NpZ25cclxuICAgICAgICBhcnJheVtiXSA9IGE7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZnVuY3Rpb25hbC9pbW11dGFibGUtZGF0YSwgbm8tcGFyYW0tcmVhc3NpZ25cclxuICAgIH1cclxuICAgIHJldHVybiBhcnJheTtcclxufVxyXG5mdW5jdGlvbiBhZGRNZXRob2RzKGJhc2UsIG1ldGhvZHMpIHtcclxuICAgIGlmICghbWV0aG9kcykge1xyXG4gICAgICAgIHJldHVybiBiYXNlO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmtleXMobWV0aG9kcykuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jdGlvbmFsL2ltbXV0YWJsZS1kYXRhLCBuby1wYXJhbS1yZWFzc2lnblxyXG4gICAgICAgIGJhc2Vba2V5XSA9IG1ldGhvZHNba2V5XShiYXNlKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGJhc2U7XHJcbn1cclxuZnVuY3Rpb24gZW5jb2RlKGZvcm1hdCwgLi4uYXJncykge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmN0aW9uYWwvbm8tbGV0XHJcbiAgICBsZXQgaSA9IDA7XHJcbiAgICByZXR1cm4gZm9ybWF0LnJlcGxhY2UoLyVzL2csICgpID0+IGVuY29kZVVSSUNvbXBvbmVudChhcmdzW2krK10pKTtcclxufVxuXG5jb25zdCB2ZXJzaW9uID0gJzQuMjMuMyc7XG5cbmNvbnN0IEF1dGhNb2RlID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBJZiBhdXRoIGNyZWRlbnRpYWxzIHNob3VsZCBiZSBpbiBxdWVyeSBwYXJhbWV0ZXJzLlxyXG4gICAgICovXHJcbiAgICBXaXRoaW5RdWVyeVBhcmFtZXRlcnM6IDAsXHJcbiAgICAvKipcclxuICAgICAqIElmIGF1dGggY3JlZGVudGlhbHMgc2hvdWxkIGJlIGluIGhlYWRlcnMuXHJcbiAgICAgKi9cclxuICAgIFdpdGhpbkhlYWRlcnM6IDEsXHJcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZU1hcHBlZFJlcXVlc3RPcHRpb25zKHJlcXVlc3RPcHRpb25zLCB0aW1lb3V0KSB7XHJcbiAgICBjb25zdCBvcHRpb25zID0gcmVxdWVzdE9wdGlvbnMgfHwge307XHJcbiAgICBjb25zdCBkYXRhID0gb3B0aW9ucy5kYXRhIHx8IHt9O1xyXG4gICAgT2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgIGlmIChbJ3RpbWVvdXQnLCAnaGVhZGVycycsICdxdWVyeVBhcmFtZXRlcnMnLCAnZGF0YScsICdjYWNoZWFibGUnXS5pbmRleE9mKGtleSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIGRhdGFba2V5XSA9IG9wdGlvbnNba2V5XTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmdW5jdGlvbmFsL2ltbXV0YWJsZS1kYXRhXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGRhdGE6IE9iamVjdC5lbnRyaWVzKGRhdGEpLmxlbmd0aCA+IDAgPyBkYXRhIDogdW5kZWZpbmVkLFxyXG4gICAgICAgIHRpbWVvdXQ6IG9wdGlvbnMudGltZW91dCB8fCB0aW1lb3V0LFxyXG4gICAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVycyB8fCB7fSxcclxuICAgICAgICBxdWVyeVBhcmFtZXRlcnM6IG9wdGlvbnMucXVlcnlQYXJhbWV0ZXJzIHx8IHt9LFxyXG4gICAgICAgIGNhY2hlYWJsZTogb3B0aW9ucy5jYWNoZWFibGUsXHJcbiAgICB9O1xyXG59XG5cbmNvbnN0IENhbGxFbnVtID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBJZiB0aGUgaG9zdCBpcyByZWFkIG9ubHkuXHJcbiAgICAgKi9cclxuICAgIFJlYWQ6IDEsXHJcbiAgICAvKipcclxuICAgICAqIElmIHRoZSBob3N0IGlzIHdyaXRlIG9ubHkuXHJcbiAgICAgKi9cclxuICAgIFdyaXRlOiAyLFxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiB0aGUgaG9zdCBpcyBib3RoIHJlYWQgYW5kIHdyaXRlLlxyXG4gICAgICovXHJcbiAgICBBbnk6IDMsXHJcbn07XG5cbmNvbnN0IEhvc3RTdGF0dXNFbnVtID0ge1xyXG4gICAgVXA6IDEsXHJcbiAgICBEb3duOiAyLFxyXG4gICAgVGltZW91dGVkOiAzLFxyXG59O1xuXG4vLyBCeSBkZWZhdWx0LCBBUEkgQ2xpZW50cyBhdCBBbGdvbGlhIGhhdmUgZXhwaXJhdGlvbiBkZWxheVxyXG4vLyBvZiA1IG1pbnMuIEluIHRoZSBKYXZhU2NyaXB0IGNsaWVudCwgd2UgaGF2ZSAyIG1pbnMuXHJcbmNvbnN0IEVYUElSQVRJT05fREVMQVkgPSAyICogNjAgKiAxMDAwO1xyXG5mdW5jdGlvbiBjcmVhdGVTdGF0ZWZ1bEhvc3QoaG9zdCwgc3RhdHVzID0gSG9zdFN0YXR1c0VudW0uVXApIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgLi4uaG9zdCxcclxuICAgICAgICBzdGF0dXMsXHJcbiAgICAgICAgbGFzdFVwZGF0ZTogRGF0ZS5ub3coKSxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaXNTdGF0ZWZ1bEhvc3RVcChob3N0KSB7XHJcbiAgICByZXR1cm4gaG9zdC5zdGF0dXMgPT09IEhvc3RTdGF0dXNFbnVtLlVwIHx8IERhdGUubm93KCkgLSBob3N0Lmxhc3RVcGRhdGUgPiBFWFBJUkFUSU9OX0RFTEFZO1xyXG59XHJcbmZ1bmN0aW9uIGlzU3RhdGVmdWxIb3N0VGltZW91dGVkKGhvc3QpIHtcclxuICAgIHJldHVybiAoaG9zdC5zdGF0dXMgPT09IEhvc3RTdGF0dXNFbnVtLlRpbWVvdXRlZCAmJiBEYXRlLm5vdygpIC0gaG9zdC5sYXN0VXBkYXRlIDw9IEVYUElSQVRJT05fREVMQVkpO1xyXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRlbGVzc0hvc3Qob3B0aW9ucykge1xyXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHByb3RvY29sOiAnaHR0cHMnLFxyXG4gICAgICAgICAgICB1cmw6IG9wdGlvbnMsXHJcbiAgICAgICAgICAgIGFjY2VwdDogQ2FsbEVudW0uQW55LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHByb3RvY29sOiBvcHRpb25zLnByb3RvY29sIHx8ICdodHRwcycsXHJcbiAgICAgICAgdXJsOiBvcHRpb25zLnVybCxcclxuICAgICAgICBhY2NlcHQ6IG9wdGlvbnMuYWNjZXB0IHx8IENhbGxFbnVtLkFueSxcclxuICAgIH07XHJcbn1cblxuY29uc3QgTWV0aG9kRW51bSA9IHtcclxuICAgIERlbGV0ZTogJ0RFTEVURScsXHJcbiAgICBHZXQ6ICdHRVQnLFxyXG4gICAgUG9zdDogJ1BPU1QnLFxyXG4gICAgUHV0OiAnUFVUJyxcclxufTtcblxuZnVuY3Rpb24gY3JlYXRlUmV0cnlhYmxlT3B0aW9ucyhob3N0c0NhY2hlLCBzdGF0ZWxlc3NIb3N0cykge1xyXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHN0YXRlbGVzc0hvc3RzLm1hcChzdGF0ZWxlc3NIb3N0ID0+IHtcclxuICAgICAgICByZXR1cm4gaG9zdHNDYWNoZS5nZXQoc3RhdGVsZXNzSG9zdCwgKCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNyZWF0ZVN0YXRlZnVsSG9zdChzdGF0ZWxlc3NIb3N0KSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KSkudGhlbihzdGF0ZWZ1bEhvc3RzID0+IHtcclxuICAgICAgICBjb25zdCBob3N0c1VwID0gc3RhdGVmdWxIb3N0cy5maWx0ZXIoaG9zdCA9PiBpc1N0YXRlZnVsSG9zdFVwKGhvc3QpKTtcclxuICAgICAgICBjb25zdCBob3N0c1RpbWVvdXRlZCA9IHN0YXRlZnVsSG9zdHMuZmlsdGVyKGhvc3QgPT4gaXNTdGF0ZWZ1bEhvc3RUaW1lb3V0ZWQoaG9zdCkpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE5vdGUsIHdlIHB1dCB0aGUgaG9zdHMgdGhhdCBwcmV2aW91c2x5IHRpbWVvdXRlZCBvbiB0aGUgZW5kIG9mIHRoZSBsaXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNvbnN0IGhvc3RzQXZhaWxhYmxlID0gWy4uLmhvc3RzVXAsIC4uLmhvc3RzVGltZW91dGVkXTtcclxuICAgICAgICBjb25zdCBzdGF0ZWxlc3NIb3N0c0F2YWlsYWJsZSA9IGhvc3RzQXZhaWxhYmxlLmxlbmd0aCA+IDBcclxuICAgICAgICAgICAgPyBob3N0c0F2YWlsYWJsZS5tYXAoaG9zdCA9PiBjcmVhdGVTdGF0ZWxlc3NIb3N0KGhvc3QpKVxyXG4gICAgICAgICAgICA6IHN0YXRlbGVzc0hvc3RzO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGdldFRpbWVvdXQodGltZW91dHNDb3VudCwgYmFzZVRpbWVvdXQpIHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogSW1hZ2luZSB0aGF0IHlvdSBoYXZlIDQgaG9zdHMsIGlmIHRpbWVvdXRzIHdpbGwgaW5jcmVhc2VcclxuICAgICAgICAgICAgICAgICAqIG9uIHRoZSBmb2xsb3dpbmcgd2F5OiAxICh0aW1lb3V0ZWQpID4gNCAodGltZW91dGVkKSA+IDUgKDIwMClcclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQsIHRoZSB2ZXJ5IG5leHQgcmVxdWVzdCwgd2Ugc3RhcnQgZnJvbSB0aGUgcHJldmlvdXMgdGltZW91dFxyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqICA1ICh0aW1lb3V0ZWQpID4gNiAodGltZW91dGVkKSA+IDcgLi4uXHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogVGhpcyBzdHJhdGVneSBtYXkgbmVlZCB0byBiZSByZXZpZXdlZCwgYnV0IGlzIHRoZSBzdHJhdGVneSBvbiB0aGUgb3VyXHJcbiAgICAgICAgICAgICAgICAgKiBjdXJyZW50IHYzIHZlcnNpb24uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVvdXRNdWx0aXBsaWVyID0gaG9zdHNUaW1lb3V0ZWQubGVuZ3RoID09PSAwICYmIHRpbWVvdXRzQ291bnQgPT09IDBcclxuICAgICAgICAgICAgICAgICAgICA/IDFcclxuICAgICAgICAgICAgICAgICAgICA6IGhvc3RzVGltZW91dGVkLmxlbmd0aCArIDMgKyB0aW1lb3V0c0NvdW50O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRpbWVvdXRNdWx0aXBsaWVyICogYmFzZVRpbWVvdXQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHN0YXRlbGVzc0hvc3RzOiBzdGF0ZWxlc3NIb3N0c0F2YWlsYWJsZSxcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbn1cblxuY29uc3QgaXNOZXR3b3JrRXJyb3IgPSAoeyBpc1RpbWVkT3V0LCBzdGF0dXMgfSkgPT4ge1xyXG4gICAgcmV0dXJuICFpc1RpbWVkT3V0ICYmIH5+c3RhdHVzID09PSAwO1xyXG59O1xyXG5jb25zdCBpc1JldHJ5YWJsZSA9IChyZXNwb25zZSkgPT4ge1xyXG4gICAgY29uc3Qgc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzO1xyXG4gICAgY29uc3QgaXNUaW1lZE91dCA9IHJlc3BvbnNlLmlzVGltZWRPdXQ7XHJcbiAgICByZXR1cm4gKGlzVGltZWRPdXQgfHwgaXNOZXR3b3JrRXJyb3IocmVzcG9uc2UpIHx8ICh+fihzdGF0dXMgLyAxMDApICE9PSAyICYmIH5+KHN0YXR1cyAvIDEwMCkgIT09IDQpKTtcclxufTtcclxuY29uc3QgaXNTdWNjZXNzID0gKHsgc3RhdHVzIH0pID0+IHtcclxuICAgIHJldHVybiB+fihzdGF0dXMgLyAxMDApID09PSAyO1xyXG59O1xyXG5jb25zdCByZXRyeURlY2lzaW9uID0gKHJlc3BvbnNlLCBvdXRjb21lcykgPT4ge1xyXG4gICAgaWYgKGlzUmV0cnlhYmxlKHJlc3BvbnNlKSkge1xyXG4gICAgICAgIHJldHVybiBvdXRjb21lcy5vblJldHJ5KHJlc3BvbnNlKTtcclxuICAgIH1cclxuICAgIGlmIChpc1N1Y2Nlc3MocmVzcG9uc2UpKSB7XHJcbiAgICAgICAgcmV0dXJuIG91dGNvbWVzLm9uU3VjY2VzcyhyZXNwb25zZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0Y29tZXMub25GYWlsKHJlc3BvbnNlKTtcclxufTtcblxuZnVuY3Rpb24gcmV0cnlhYmxlUmVxdWVzdCh0cmFuc3BvcnRlciwgc3RhdGVsZXNzSG9zdHMsIHJlcXVlc3QsIHJlcXVlc3RPcHRpb25zKSB7XHJcbiAgICBjb25zdCBzdGFja1RyYWNlID0gW107IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZnVuY3Rpb25hbC9wcmVmZXItcmVhZG9ubHktdHlwZVxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJzdCB3ZSBwcmVwYXJlIHRoZSBwYXlsb2FkIHRoYXQgZG8gbm90IGRlcGVuZCBmcm9tIGhvc3RzLlxyXG4gICAgICovXHJcbiAgICBjb25zdCBkYXRhID0gc2VyaWFsaXplRGF0YShyZXF1ZXN0LCByZXF1ZXN0T3B0aW9ucyk7XHJcbiAgICBjb25zdCBoZWFkZXJzID0gc2VyaWFsaXplSGVhZGVycyh0cmFuc3BvcnRlciwgcmVxdWVzdE9wdGlvbnMpO1xyXG4gICAgY29uc3QgbWV0aG9kID0gcmVxdWVzdC5tZXRob2Q7XHJcbiAgICAvLyBPbiBgR0VUYCwgdGhlIGRhdGEgaXMgcHJveGllZCB0byBxdWVyeSBwYXJhbWV0ZXJzLlxyXG4gICAgY29uc3QgZGF0YVF1ZXJ5UGFyYW1ldGVycyA9IHJlcXVlc3QubWV0aG9kICE9PSBNZXRob2RFbnVtLkdldFxyXG4gICAgICAgID8ge31cclxuICAgICAgICA6IHtcclxuICAgICAgICAgICAgLi4ucmVxdWVzdC5kYXRhLFxyXG4gICAgICAgICAgICAuLi5yZXF1ZXN0T3B0aW9ucy5kYXRhLFxyXG4gICAgICAgIH07XHJcbiAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7XHJcbiAgICAgICAgJ3gtYWxnb2xpYS1hZ2VudCc6IHRyYW5zcG9ydGVyLnVzZXJBZ2VudC52YWx1ZSxcclxuICAgICAgICAuLi50cmFuc3BvcnRlci5xdWVyeVBhcmFtZXRlcnMsXHJcbiAgICAgICAgLi4uZGF0YVF1ZXJ5UGFyYW1ldGVycyxcclxuICAgICAgICAuLi5yZXF1ZXN0T3B0aW9ucy5xdWVyeVBhcmFtZXRlcnMsXHJcbiAgICB9O1xyXG4gICAgbGV0IHRpbWVvdXRzQ291bnQgPSAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmN0aW9uYWwvbm8tbGV0XHJcbiAgICBjb25zdCByZXRyeSA9IChob3N0cywgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmdW5jdGlvbmFsL3ByZWZlci1yZWFkb25seS10eXBlXHJcbiAgICBnZXRUaW1lb3V0KSA9PiB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2UgaXRlcmF0ZSBvbiBlYWNoIGhvc3QsIHVudGlsIHRoZXJlIGlzIG5vIGhvc3QgbGVmdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBjb25zdCBob3N0ID0gaG9zdHMucG9wKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZnVuY3Rpb25hbC9pbW11dGFibGUtZGF0YVxyXG4gICAgICAgIGlmIChob3N0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlUmV0cnlFcnJvcihzdGFja1RyYWNlV2l0aG91dENyZWRlbnRpYWxzKHN0YWNrVHJhY2UpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHtcclxuICAgICAgICAgICAgZGF0YSxcclxuICAgICAgICAgICAgaGVhZGVycyxcclxuICAgICAgICAgICAgbWV0aG9kLFxyXG4gICAgICAgICAgICB1cmw6IHNlcmlhbGl6ZVVybChob3N0LCByZXF1ZXN0LnBhdGgsIHF1ZXJ5UGFyYW1ldGVycyksXHJcbiAgICAgICAgICAgIGNvbm5lY3RUaW1lb3V0OiBnZXRUaW1lb3V0KHRpbWVvdXRzQ291bnQsIHRyYW5zcG9ydGVyLnRpbWVvdXRzLmNvbm5lY3QpLFxyXG4gICAgICAgICAgICByZXNwb25zZVRpbWVvdXQ6IGdldFRpbWVvdXQodGltZW91dHNDb3VudCwgcmVxdWVzdE9wdGlvbnMudGltZW91dCksXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgc3RhY2tGcmFtZSBpcyBwdXNoZWQgdG8gdGhlIHN0YWNrVHJhY2Ugc28gd2VcclxuICAgICAgICAgKiBjYW4gaGF2ZSBpbmZvcm1hdGlvbiBhYm91dCBvblJldHJ5IGFuZCBvbkZhaWx1cmVcclxuICAgICAgICAgKiBkZWNpc2lvbnMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29uc3QgcHVzaFRvU3RhY2tUcmFjZSA9IChyZXNwb25zZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzdGFja0ZyYW1lID0ge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdDogcGF5bG9hZCxcclxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxyXG4gICAgICAgICAgICAgICAgaG9zdCxcclxuICAgICAgICAgICAgICAgIHRyaWVzTGVmdDogaG9zdHMubGVuZ3RoLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuY3Rpb25hbC9pbW11dGFibGUtZGF0YVxyXG4gICAgICAgICAgICBzdGFja1RyYWNlLnB1c2goc3RhY2tGcmFtZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBzdGFja0ZyYW1lO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgZGVjaXNpb25zID0ge1xyXG4gICAgICAgICAgICBvblN1Y2Nlc3M6IHJlc3BvbnNlID0+IGRlc2VyaWFsaXplU3VjY2VzcyhyZXNwb25zZSksXHJcbiAgICAgICAgICAgIG9uUmV0cnkocmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YWNrRnJhbWUgPSBwdXNoVG9TdGFja1RyYWNlKHJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogSWYgcmVzcG9uc2UgaXMgYSB0aW1lb3V0LCB3ZSBpbmNyZWFzZXQgdGhlIG51bWJlciBvZlxyXG4gICAgICAgICAgICAgICAgICogdGltZW91dHMgc28gd2UgY2FuIGluY3JlYXNlIHRoZSB0aW1lb3V0IGxhdGVyLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuaXNUaW1lZE91dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXRzQ291bnQrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogRmFpbHVyZXMgYXJlIGluZGl2aWR1YWxseSBzZW5kIHRoZSBsb2dnZXIsIGFsbG93aW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICogdGhlIGVuZCB1c2VyIHRvIGRlYnVnIC8gc3RvcmUgc3RhY2sgZnJhbWVzIGV2ZW5cclxuICAgICAgICAgICAgICAgICAgICAgKiB3aGVuIGEgcmV0cnkgZXJyb3IgZG9lcyBub3QgaGFwcGVuLlxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydGVyLmxvZ2dlci5pbmZvKCdSZXRyeWFibGUgZmFpbHVyZScsIHN0YWNrRnJhbWVXaXRob3V0Q3JlZGVudGlhbHMoc3RhY2tGcmFtZSkpLFxyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIFdlIGFsc28gc3RvcmUgdGhlIHN0YXRlIG9mIHRoZSBob3N0IGluIGZhaWx1cmUgY2FzZXMuIElmIHRoZSBob3N0LCBpc1xyXG4gICAgICAgICAgICAgICAgICAgICAqIGRvd24gaXQgd2lsbCByZW1haW4gZG93biBmb3IgdGhlIG5leHQgMiBtaW51dGVzLiBJbiBhIHRpbWVvdXQgc2l0dWF0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAqIHRoaXMgaG9zdCB3aWxsIGJlIGFkZGVkIGVuZCBvZiB0aGUgbGlzdCBvZiBob3N0cyBvbiB0aGUgbmV4dCByZXF1ZXN0LlxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydGVyLmhvc3RzQ2FjaGUuc2V0KGhvc3QsIGNyZWF0ZVN0YXRlZnVsSG9zdChob3N0LCByZXNwb25zZS5pc1RpbWVkT3V0ID8gSG9zdFN0YXR1c0VudW0uVGltZW91dGVkIDogSG9zdFN0YXR1c0VudW0uRG93bikpLFxyXG4gICAgICAgICAgICAgICAgXSkudGhlbigoKSA9PiByZXRyeShob3N0cywgZ2V0VGltZW91dCkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvbkZhaWwocmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgICAgIHB1c2hUb1N0YWNrVHJhY2UocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZGVzZXJpYWxpemVGYWlsdXJlKHJlc3BvbnNlLCBzdGFja1RyYWNlV2l0aG91dENyZWRlbnRpYWxzKHN0YWNrVHJhY2UpKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB0cmFuc3BvcnRlci5yZXF1ZXN0ZXIuc2VuZChwYXlsb2FkKS50aGVuKHJlc3BvbnNlID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHJldHJ5RGVjaXNpb24ocmVzcG9uc2UsIGRlY2lzaW9ucyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5hbGx5LCBmb3IgZWFjaCByZXRyeWFibGUgaG9zdCBwZXJmb3JtIHJlcXVlc3QgdW50aWwgd2UgZ290IGEgbm9uXHJcbiAgICAgKiByZXRyeWFibGUgcmVzcG9uc2UuIFNvbWUgbm90ZXMgaGVyZTpcclxuICAgICAqXHJcbiAgICAgKiAxLiBUaGUgcmV2ZXJzZSBoZXJlIGlzIGFwcGxpZWQgc28gd2UgY2FuIGFwcGx5IGEgYHBvcGAgbGF0ZXIgb24gPT4gbW9yZSBwZXJmb3JtYW50LlxyXG4gICAgICogMi4gV2UgYWxzbyBnZXQgZnJvbSB0aGUgcmV0cnlhYmxlIG9wdGlvbnMgYSB0aW1lb3V0IG11bHRpcGxpZXIgdGhhdCBpcyB0YWlsb3JlZFxyXG4gICAgICogZm9yIHRoZSBjdXJyZW50IGNvbnRleHQuXHJcbiAgICAgKi9cclxuICAgIHJldHVybiBjcmVhdGVSZXRyeWFibGVPcHRpb25zKHRyYW5zcG9ydGVyLmhvc3RzQ2FjaGUsIHN0YXRlbGVzc0hvc3RzKS50aGVuKG9wdGlvbnMgPT4ge1xyXG4gICAgICAgIHJldHVybiByZXRyeShbLi4ub3B0aW9ucy5zdGF0ZWxlc3NIb3N0c10ucmV2ZXJzZSgpLCBvcHRpb25zLmdldFRpbWVvdXQpO1xyXG4gICAgfSk7XHJcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHJhbnNwb3J0ZXIob3B0aW9ucykge1xyXG4gICAgY29uc3QgeyBob3N0c0NhY2hlLCBsb2dnZXIsIHJlcXVlc3RlciwgcmVxdWVzdHNDYWNoZSwgcmVzcG9uc2VzQ2FjaGUsIHRpbWVvdXRzLCB1c2VyQWdlbnQsIGhvc3RzLCBxdWVyeVBhcmFtZXRlcnMsIGhlYWRlcnMsIH0gPSBvcHRpb25zO1xyXG4gICAgY29uc3QgdHJhbnNwb3J0ZXIgPSB7XHJcbiAgICAgICAgaG9zdHNDYWNoZSxcclxuICAgICAgICBsb2dnZXIsXHJcbiAgICAgICAgcmVxdWVzdGVyLFxyXG4gICAgICAgIHJlcXVlc3RzQ2FjaGUsXHJcbiAgICAgICAgcmVzcG9uc2VzQ2FjaGUsXHJcbiAgICAgICAgdGltZW91dHMsXHJcbiAgICAgICAgdXNlckFnZW50LFxyXG4gICAgICAgIGhlYWRlcnMsXHJcbiAgICAgICAgcXVlcnlQYXJhbWV0ZXJzLFxyXG4gICAgICAgIGhvc3RzOiBob3N0cy5tYXAoaG9zdCA9PiBjcmVhdGVTdGF0ZWxlc3NIb3N0KGhvc3QpKSxcclxuICAgICAgICByZWFkKHJlcXVlc3QsIHJlcXVlc3RPcHRpb25zKSB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBGaXJzdCwgd2UgY29tcHV0ZSB0aGUgdXNlciByZXF1ZXN0IG9wdGlvbnMuIE5vdywga2VlcCBpbiBtaW5kLFxyXG4gICAgICAgICAgICAgKiB0aGF0IHVzaW5nIHJlcXVlc3Qgb3B0aW9ucyB0aGUgdXNlciBpcyBhYmxlIHRvIG1vZGlmaWVkIHRoZSBpbnRpcmVcclxuICAgICAgICAgICAgICogcGF5bG9hZCBvZiB0aGUgcmVxdWVzdC4gU3VjaCBhcyBoZWFkZXJzLCBxdWVyeSBwYXJhbWV0ZXJzLCBhbmQgb3RoZXJzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgY29uc3QgbWFwcGVkUmVxdWVzdE9wdGlvbnMgPSBjcmVhdGVNYXBwZWRSZXF1ZXN0T3B0aW9ucyhyZXF1ZXN0T3B0aW9ucywgdHJhbnNwb3J0ZXIudGltZW91dHMucmVhZCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZVJldHJ5YWJsZVJlcXVlc3QgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZW4sIHdlIHByZXBhcmUgYSBmdW5jdGlvbiBmYWN0b3J5IHRoYXQgY29udGFpbnMgdGhlIGNvbnN0cnVjdGlvbiBvZlxyXG4gICAgICAgICAgICAgICAgICogdGhlIHJldHJ5YWJsZSByZXF1ZXN0LiBBdCB0aGlzIHBvaW50LCB3ZSBtYXkgKm5vdCogcGVyZm9ybSB0aGUgYWN0dWFsXHJcbiAgICAgICAgICAgICAgICAgKiByZXF1ZXN0LiBCdXQgd2Ugd2FudCB0byBoYXZlIHRoZSBmdW5jdGlvbiBmYWN0b3J5IHJlYWR5LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0cnlhYmxlUmVxdWVzdCh0cmFuc3BvcnRlciwgdHJhbnNwb3J0ZXIuaG9zdHMuZmlsdGVyKGhvc3QgPT4gKGhvc3QuYWNjZXB0ICYgQ2FsbEVudW0uUmVhZCkgIT09IDApLCByZXF1ZXN0LCBtYXBwZWRSZXF1ZXN0T3B0aW9ucyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBPbmNlIHdlIGhhdmUgdGhlIGZ1bmN0aW9uIGZhY3RvcnkgcmVhZHksIHdlIG5lZWQgdG8gZGV0ZXJtaW5lIG9mIHRoZVxyXG4gICAgICAgICAgICAgKiByZXF1ZXN0IGlzIFwiY2FjaGVhYmxlXCIgLSBzaG91bGQgYmUgY2FjaGVkLiBOb3RlIHRoYXQsIG9uY2UgYWdhaW4sXHJcbiAgICAgICAgICAgICAqIHRoZSB1c2VyIGNhbiBmb3JjZSB0aGlzIG9wdGlvbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlYWJsZSA9IG1hcHBlZFJlcXVlc3RPcHRpb25zLmNhY2hlYWJsZSAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICA/IG1hcHBlZFJlcXVlc3RPcHRpb25zLmNhY2hlYWJsZVxyXG4gICAgICAgICAgICAgICAgOiByZXF1ZXN0LmNhY2hlYWJsZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIElmIGlzIG5vdCBcImNhY2hlYWJsZVwiLCB3ZSBpbW1lZGlhdGx5IHRyaWdnZXIgdGhlIHJldHJ5YWJsZSByZXF1ZXN0LCBub1xyXG4gICAgICAgICAgICAgKiBuZWVkIHRvIGNoZWNrIGNhY2hlIGltcGxlbWVudGF0aW9ucy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGlmIChjYWNoZWFibGUgIT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVSZXRyeWFibGVSZXF1ZXN0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIElmIHRoZSByZXF1ZXN0IGlzIFwiY2FjaGVhYmxlXCIsIHdlIG5lZWQgdG8gZmlyc3QgY29tcHV0ZSB0aGUga2V5IHRvIGFza1xyXG4gICAgICAgICAgICAgKiB0aGUgY2FjaGUgaW1wbGVtZW50YXRpb25zIGlmIHRoaXMgcmVxdWVzdCBpcyBvbiBwcm9ncmVzcyBvciBpZiB0aGVcclxuICAgICAgICAgICAgICogcmVzcG9uc2UgYWxyZWFkeSBleGlzdHMgb24gdGhlIGNhY2hlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgY29uc3Qga2V5ID0ge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcclxuICAgICAgICAgICAgICAgIG1hcHBlZFJlcXVlc3RPcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0ZXI6IHtcclxuICAgICAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnM6IHRyYW5zcG9ydGVyLnF1ZXJ5UGFyYW1ldGVycyxcclxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0cmFuc3BvcnRlci5oZWFkZXJzLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdpdGggdGhlIGNvbXB1dGVkIGtleSwgd2UgZmlyc3QgYXNrIHRoZSByZXNwb25zZXMgY2FjaGVcclxuICAgICAgICAgICAgICogaW1wbGVtZW50aW9uIGlmIHRoaXMgcmVxdWVzdCB3YXMgYmVlbiByZXNvbHZlZCBiZWZvcmUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICByZXR1cm4gdHJhbnNwb3J0ZXIucmVzcG9uc2VzQ2FjaGUuZ2V0KGtleSwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBJZiB0aGUgcmVxdWVzdCBoYXMgbmV2ZXIgcmVzb2x2ZWQgYmVmb3JlLCB3ZSBhY3R1YWxseSBhc2sgaWYgdGhlcmVcclxuICAgICAgICAgICAgICAgICAqIGlzIGEgY3VycmVudCByZXF1ZXN0IHdpdGggdGhlIHNhbWUga2V5IG9uIHByb2dyZXNzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNwb3J0ZXIucmVxdWVzdHNDYWNoZS5nZXQoa2V5LCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0cmFuc3BvcnRlci5yZXF1ZXN0c0NhY2hlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBGaW5hbGx5LCBpZiB0aGVyZSBpcyBubyByZXF1ZXN0IGluIHByb2dyZXNzIHdpdGggdGhlIHNhbWUga2V5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiB0aGlzIGBjcmVhdGVSZXRyeWFibGVSZXF1ZXN0KClgIHdpbGwgYWN0dWFsbHkgdHJpZ2dlciB0aGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICogcmV0cnlhYmxlIHJlcXVlc3QuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0KGtleSwgY3JlYXRlUmV0cnlhYmxlUmVxdWVzdCgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihyZXNwb25zZSA9PiBQcm9taXNlLmFsbChbdHJhbnNwb3J0ZXIucmVxdWVzdHNDYWNoZS5kZWxldGUoa2V5KSwgcmVzcG9uc2VdKSwgZXJyID0+IFByb21pc2UuYWxsKFt0cmFuc3BvcnRlci5yZXF1ZXN0c0NhY2hlLmRlbGV0ZShrZXkpLCBQcm9taXNlLnJlamVjdChlcnIpXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKChbXywgcmVzcG9uc2VdKSA9PiByZXNwb25zZSkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0sIHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogT2YgY291cnNlLCBvbmNlIHdlIGdldCB0aGlzIHJlc3BvbnNlIGJhY2sgZnJvbSB0aGUgc2VydmVyLCB3ZVxyXG4gICAgICAgICAgICAgICAgICogdGVsbCByZXNwb25zZSBjYWNoZSB0byBhY3R1YWxseSBzdG9yZSB0aGUgcmVjZWl2ZWQgcmVzcG9uc2VcclxuICAgICAgICAgICAgICAgICAqIHRvIGJlIHVzZWQgbGF0ZXIuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIG1pc3M6IHJlc3BvbnNlID0+IHRyYW5zcG9ydGVyLnJlc3BvbnNlc0NhY2hlLnNldChrZXksIHJlc3BvbnNlKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB3cml0ZShyZXF1ZXN0LCByZXF1ZXN0T3B0aW9ucykge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogT24gd3JpdGUgcmVxdWVzdHMsIG5vIGNhY2hlIG1lY2hhbmlzbXMgYXJlIGFwcGxpZWQsIGFuZCB3ZVxyXG4gICAgICAgICAgICAgKiBwcm94eSB0aGUgcmVxdWVzdCBpbW1lZGlhdGVseSB0byB0aGUgcmVxdWVzdGVyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgcmV0dXJuIHJldHJ5YWJsZVJlcXVlc3QodHJhbnNwb3J0ZXIsIHRyYW5zcG9ydGVyLmhvc3RzLmZpbHRlcihob3N0ID0+IChob3N0LmFjY2VwdCAmIENhbGxFbnVtLldyaXRlKSAhPT0gMCksIHJlcXVlc3QsIGNyZWF0ZU1hcHBlZFJlcXVlc3RPcHRpb25zKHJlcXVlc3RPcHRpb25zLCB0cmFuc3BvcnRlci50aW1lb3V0cy53cml0ZSkpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHRyYW5zcG9ydGVyO1xyXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVVzZXJBZ2VudCh2ZXJzaW9uKSB7XHJcbiAgICBjb25zdCB1c2VyQWdlbnQgPSB7XHJcbiAgICAgICAgdmFsdWU6IGBBbGdvbGlhIGZvciBKYXZhU2NyaXB0ICgke3ZlcnNpb259KWAsXHJcbiAgICAgICAgYWRkKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgY29uc3QgYWRkZWRVc2VyQWdlbnQgPSBgOyAke29wdGlvbnMuc2VnbWVudH0ke29wdGlvbnMudmVyc2lvbiAhPT0gdW5kZWZpbmVkID8gYCAoJHtvcHRpb25zLnZlcnNpb259KWAgOiAnJ31gO1xyXG4gICAgICAgICAgICBpZiAodXNlckFnZW50LnZhbHVlLmluZGV4T2YoYWRkZWRVc2VyQWdlbnQpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmN0aW9uYWwvaW1tdXRhYmxlLWRhdGFcclxuICAgICAgICAgICAgICAgIHVzZXJBZ2VudC52YWx1ZSA9IGAke3VzZXJBZ2VudC52YWx1ZX0ke2FkZGVkVXNlckFnZW50fWA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHVzZXJBZ2VudDtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxuICAgIHJldHVybiB1c2VyQWdlbnQ7XHJcbn1cblxuZnVuY3Rpb24gZGVzZXJpYWxpemVTdWNjZXNzKHJlc3BvbnNlKSB7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuY3Rpb25hbC9uby10cnktc3RhdGVtZW50XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHJlc3BvbnNlLmNvbnRlbnQpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICB0aHJvdyBjcmVhdGVEZXNlcmlhbGl6YXRpb25FcnJvcihlLm1lc3NhZ2UsIHJlc3BvbnNlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBkZXNlcmlhbGl6ZUZhaWx1cmUoeyBjb250ZW50LCBzdGF0dXMgfSwgc3RhY2tGcmFtZSkge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmN0aW9uYWwvbm8tbGV0XHJcbiAgICBsZXQgbWVzc2FnZSA9IGNvbnRlbnQ7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuY3Rpb25hbC9uby10cnktc3RhdGVtZW50XHJcbiAgICB0cnkge1xyXG4gICAgICAgIG1lc3NhZ2UgPSBKU09OLnBhcnNlKGNvbnRlbnQpLm1lc3NhZ2U7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIC8vIC4uXHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3JlYXRlQXBpRXJyb3IobWVzc2FnZSwgc3RhdHVzLCBzdGFja0ZyYW1lKTtcclxufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVVcmwoaG9zdCwgcGF0aCwgcXVlcnlQYXJhbWV0ZXJzKSB7XHJcbiAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnNBc1N0cmluZyA9IHNlcmlhbGl6ZVF1ZXJ5UGFyYW1ldGVycyhxdWVyeVBhcmFtZXRlcnMpO1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmN0aW9uYWwvbm8tbGV0XHJcbiAgICBsZXQgdXJsID0gYCR7aG9zdC5wcm90b2NvbH06Ly8ke2hvc3QudXJsfS8ke3BhdGguY2hhckF0KDApID09PSAnLycgPyBwYXRoLnN1YnN0cigxKSA6IHBhdGh9YDtcclxuICAgIGlmIChxdWVyeVBhcmFtZXRlcnNBc1N0cmluZy5sZW5ndGgpIHtcclxuICAgICAgICB1cmwgKz0gYD8ke3F1ZXJ5UGFyYW1ldGVyc0FzU3RyaW5nfWA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdXJsO1xyXG59XHJcbmZ1bmN0aW9uIHNlcmlhbGl6ZVF1ZXJ5UGFyYW1ldGVycyhwYXJhbWV0ZXJzKSB7XHJcbiAgICBjb25zdCBpc09iamVjdE9yQXJyYXkgPSAodmFsdWUpID0+IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE9iamVjdF0nIHx8XHJcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcclxuICAgIHJldHVybiBPYmplY3Qua2V5cyhwYXJhbWV0ZXJzKVxyXG4gICAgICAgIC5tYXAoa2V5ID0+IGVuY29kZSgnJXM9JXMnLCBrZXksIGlzT2JqZWN0T3JBcnJheShwYXJhbWV0ZXJzW2tleV0pID8gSlNPTi5zdHJpbmdpZnkocGFyYW1ldGVyc1trZXldKSA6IHBhcmFtZXRlcnNba2V5XSkpXHJcbiAgICAgICAgLmpvaW4oJyYnKTtcclxufVxyXG5mdW5jdGlvbiBzZXJpYWxpemVEYXRhKHJlcXVlc3QsIHJlcXVlc3RPcHRpb25zKSB7XHJcbiAgICBpZiAocmVxdWVzdC5tZXRob2QgPT09IE1ldGhvZEVudW0uR2V0IHx8XHJcbiAgICAgICAgKHJlcXVlc3QuZGF0YSA9PT0gdW5kZWZpbmVkICYmIHJlcXVlc3RPcHRpb25zLmRhdGEgPT09IHVuZGVmaW5lZCkpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGF0YSA9IEFycmF5LmlzQXJyYXkocmVxdWVzdC5kYXRhKVxyXG4gICAgICAgID8gcmVxdWVzdC5kYXRhXHJcbiAgICAgICAgOiB7IC4uLnJlcXVlc3QuZGF0YSwgLi4ucmVxdWVzdE9wdGlvbnMuZGF0YSB9O1xyXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xyXG59XHJcbmZ1bmN0aW9uIHNlcmlhbGl6ZUhlYWRlcnModHJhbnNwb3J0ZXIsIHJlcXVlc3RPcHRpb25zKSB7XHJcbiAgICBjb25zdCBoZWFkZXJzID0ge1xyXG4gICAgICAgIC4uLnRyYW5zcG9ydGVyLmhlYWRlcnMsXHJcbiAgICAgICAgLi4ucmVxdWVzdE9wdGlvbnMuaGVhZGVycyxcclxuICAgIH07XHJcbiAgICBjb25zdCBzZXJpYWxpemVkSGVhZGVycyA9IHt9O1xyXG4gICAgT2JqZWN0LmtleXMoaGVhZGVycykuZm9yRWFjaChoZWFkZXIgPT4ge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gaGVhZGVyc1toZWFkZXJdO1xyXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuY3Rpb25hbC9pbW11dGFibGUtZGF0YVxyXG4gICAgICAgIHNlcmlhbGl6ZWRIZWFkZXJzW2hlYWRlci50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gc2VyaWFsaXplZEhlYWRlcnM7XHJcbn1cblxuZnVuY3Rpb24gc3RhY2tUcmFjZVdpdGhvdXRDcmVkZW50aWFscyhzdGFja1RyYWNlKSB7XHJcbiAgICByZXR1cm4gc3RhY2tUcmFjZS5tYXAoc3RhY2tGcmFtZSA9PiBzdGFja0ZyYW1lV2l0aG91dENyZWRlbnRpYWxzKHN0YWNrRnJhbWUpKTtcclxufVxyXG5mdW5jdGlvbiBzdGFja0ZyYW1lV2l0aG91dENyZWRlbnRpYWxzKHN0YWNrRnJhbWUpIHtcclxuICAgIGNvbnN0IG1vZGlmaWVkSGVhZGVycyA9IHN0YWNrRnJhbWUucmVxdWVzdC5oZWFkZXJzWyd4LWFsZ29saWEtYXBpLWtleSddXHJcbiAgICAgICAgPyB7ICd4LWFsZ29saWEtYXBpLWtleSc6ICcqKioqKicgfVxyXG4gICAgICAgIDoge307XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIC4uLnN0YWNrRnJhbWUsXHJcbiAgICAgICAgcmVxdWVzdDoge1xyXG4gICAgICAgICAgICAuLi5zdGFja0ZyYW1lLnJlcXVlc3QsXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAgIC4uLnN0YWNrRnJhbWUucmVxdWVzdC5oZWFkZXJzLFxyXG4gICAgICAgICAgICAgICAgLi4ubW9kaWZpZWRIZWFkZXJzLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFwaUVycm9yKG1lc3NhZ2UsIHN0YXR1cywgdHJhbnNwb3J0ZXJTdGFja1RyYWNlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5hbWU6ICdBcGlFcnJvcicsXHJcbiAgICAgICAgbWVzc2FnZSxcclxuICAgICAgICBzdGF0dXMsXHJcbiAgICAgICAgdHJhbnNwb3J0ZXJTdGFja1RyYWNlLFxyXG4gICAgfTtcclxufVxuXG5mdW5jdGlvbiBjcmVhdGVEZXNlcmlhbGl6YXRpb25FcnJvcihtZXNzYWdlLCByZXNwb25zZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuYW1lOiAnRGVzZXJpYWxpemF0aW9uRXJyb3InLFxyXG4gICAgICAgIG1lc3NhZ2UsXHJcbiAgICAgICAgcmVzcG9uc2UsXHJcbiAgICB9O1xyXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJldHJ5RXJyb3IodHJhbnNwb3J0ZXJTdGFja1RyYWNlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5hbWU6ICdSZXRyeUVycm9yJyxcclxuICAgICAgICBtZXNzYWdlOiAnVW5yZWFjaGFibGUgaG9zdHMgLSB5b3VyIGFwcGxpY2F0aW9uIGlkIG1heSBiZSBpbmNvcnJlY3QuIElmIHRoZSBlcnJvciBwZXJzaXN0cywgY29udGFjdCBzdXBwb3J0QGFsZ29saWEuY29tLicsXHJcbiAgICAgICAgdHJhbnNwb3J0ZXJTdGFja1RyYWNlLFxyXG4gICAgfTtcclxufVxuXG5jb25zdCBjcmVhdGVTZWFyY2hDbGllbnQgPSBvcHRpb25zID0+IHtcclxuICAgIGNvbnN0IGFwcElkID0gb3B0aW9ucy5hcHBJZDtcclxuICAgIGNvbnN0IGF1dGggPSBjcmVhdGVBdXRoKG9wdGlvbnMuYXV0aE1vZGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYXV0aE1vZGUgOiBBdXRoTW9kZS5XaXRoaW5IZWFkZXJzLCBhcHBJZCwgb3B0aW9ucy5hcGlLZXkpO1xyXG4gICAgY29uc3QgdHJhbnNwb3J0ZXIgPSBjcmVhdGVUcmFuc3BvcnRlcih7XHJcbiAgICAgICAgaG9zdHM6IFtcclxuICAgICAgICAgICAgeyB1cmw6IGAke2FwcElkfS1kc24uYWxnb2xpYS5uZXRgLCBhY2NlcHQ6IENhbGxFbnVtLlJlYWQgfSxcclxuICAgICAgICAgICAgeyB1cmw6IGAke2FwcElkfS5hbGdvbGlhLm5ldGAsIGFjY2VwdDogQ2FsbEVudW0uV3JpdGUgfSxcclxuICAgICAgICBdLmNvbmNhdChzaHVmZmxlKFtcclxuICAgICAgICAgICAgeyB1cmw6IGAke2FwcElkfS0xLmFsZ29saWFuZXQuY29tYCB9LFxyXG4gICAgICAgICAgICB7IHVybDogYCR7YXBwSWR9LTIuYWxnb2xpYW5ldC5jb21gIH0sXHJcbiAgICAgICAgICAgIHsgdXJsOiBgJHthcHBJZH0tMy5hbGdvbGlhbmV0LmNvbWAgfSxcclxuICAgICAgICBdKSksXHJcbiAgICAgICAgLi4ub3B0aW9ucyxcclxuICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgIC4uLmF1dGguaGVhZGVycygpLFxyXG4gICAgICAgICAgICAuLi57ICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyB9LFxyXG4gICAgICAgICAgICAuLi5vcHRpb25zLmhlYWRlcnMsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBxdWVyeVBhcmFtZXRlcnM6IHtcclxuICAgICAgICAgICAgLi4uYXV0aC5xdWVyeVBhcmFtZXRlcnMoKSxcclxuICAgICAgICAgICAgLi4ub3B0aW9ucy5xdWVyeVBhcmFtZXRlcnMsXHJcbiAgICAgICAgfSxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgYmFzZSA9IHtcclxuICAgICAgICB0cmFuc3BvcnRlcixcclxuICAgICAgICBhcHBJZCxcclxuICAgICAgICBhZGRBbGdvbGlhQWdlbnQoc2VnbWVudCwgdmVyc2lvbikge1xyXG4gICAgICAgICAgICB0cmFuc3BvcnRlci51c2VyQWdlbnQuYWRkKHsgc2VnbWVudCwgdmVyc2lvbiB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNsZWFyQ2FjaGUoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXHJcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnRlci5yZXF1ZXN0c0NhY2hlLmNsZWFyKCksXHJcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnRlci5yZXNwb25zZXNDYWNoZS5jbGVhcigpLFxyXG4gICAgICAgICAgICBdKS50aGVuKCgpID0+IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbiAgICByZXR1cm4gYWRkTWV0aG9kcyhiYXNlLCBvcHRpb25zLm1ldGhvZHMpO1xyXG59O1xuXG5jb25zdCBjdXN0b21SZXF1ZXN0ID0gKGJhc2UpID0+IHtcclxuICAgIHJldHVybiAocmVxdWVzdCwgcmVxdWVzdE9wdGlvbnMpID0+IHtcclxuICAgICAgICBpZiAocmVxdWVzdC5tZXRob2QgPT09IE1ldGhvZEVudW0uR2V0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiYXNlLnRyYW5zcG9ydGVyLnJlYWQocmVxdWVzdCwgcmVxdWVzdE9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYmFzZS50cmFuc3BvcnRlci53cml0ZShyZXF1ZXN0LCByZXF1ZXN0T3B0aW9ucyk7XHJcbiAgICB9O1xyXG59O1xuXG5jb25zdCBpbml0SW5kZXggPSAoYmFzZSkgPT4ge1xyXG4gICAgcmV0dXJuIChpbmRleE5hbWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHNlYXJjaEluZGV4ID0ge1xyXG4gICAgICAgICAgICB0cmFuc3BvcnRlcjogYmFzZS50cmFuc3BvcnRlcixcclxuICAgICAgICAgICAgYXBwSWQ6IGJhc2UuYXBwSWQsXHJcbiAgICAgICAgICAgIGluZGV4TmFtZSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBhZGRNZXRob2RzKHNlYXJjaEluZGV4LCBvcHRpb25zLm1ldGhvZHMpO1xyXG4gICAgfTtcclxufTtcblxuY29uc3QgbXVsdGlwbGVRdWVyaWVzID0gKGJhc2UpID0+IHtcclxuICAgIHJldHVybiAocXVlcmllcywgcmVxdWVzdE9wdGlvbnMpID0+IHtcclxuICAgICAgICBjb25zdCByZXF1ZXN0cyA9IHF1ZXJpZXMubWFwKHF1ZXJ5ID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIC4uLnF1ZXJ5LFxyXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBzZXJpYWxpemVRdWVyeVBhcmFtZXRlcnMocXVlcnkucGFyYW1zIHx8IHt9KSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gYmFzZS50cmFuc3BvcnRlci5yZWFkKHtcclxuICAgICAgICAgICAgbWV0aG9kOiBNZXRob2RFbnVtLlBvc3QsXHJcbiAgICAgICAgICAgIHBhdGg6ICcxL2luZGV4ZXMvKi9xdWVyaWVzJyxcclxuICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdHMsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNhY2hlYWJsZTogdHJ1ZSxcclxuICAgICAgICB9LCByZXF1ZXN0T3B0aW9ucyk7XHJcbiAgICB9O1xyXG59O1xuXG5jb25zdCBtdWx0aXBsZVNlYXJjaEZvckZhY2V0VmFsdWVzID0gKGJhc2UpID0+IHtcclxuICAgIHJldHVybiAocXVlcmllcywgcmVxdWVzdE9wdGlvbnMpID0+IHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocXVlcmllcy5tYXAocXVlcnkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB7IGZhY2V0TmFtZSwgZmFjZXRRdWVyeSwgLi4ucGFyYW1zIH0gPSBxdWVyeS5wYXJhbXM7XHJcbiAgICAgICAgICAgIHJldHVybiBpbml0SW5kZXgoYmFzZSkocXVlcnkuaW5kZXhOYW1lLCB7XHJcbiAgICAgICAgICAgICAgICBtZXRob2RzOiB7IHNlYXJjaEZvckZhY2V0VmFsdWVzIH0sXHJcbiAgICAgICAgICAgIH0pLnNlYXJjaEZvckZhY2V0VmFsdWVzKGZhY2V0TmFtZSwgZmFjZXRRdWVyeSwge1xyXG4gICAgICAgICAgICAgICAgLi4ucmVxdWVzdE9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAuLi5wYXJhbXMsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pKTtcclxuICAgIH07XHJcbn07XG5cbmNvbnN0IGZpbmRBbnN3ZXJzID0gKGJhc2UpID0+IHtcclxuICAgIHJldHVybiAocXVlcnksIHF1ZXJ5TGFuZ3VhZ2VzLCByZXF1ZXN0T3B0aW9ucykgPT4ge1xyXG4gICAgICAgIHJldHVybiBiYXNlLnRyYW5zcG9ydGVyLnJlYWQoe1xyXG4gICAgICAgICAgICBtZXRob2Q6IE1ldGhvZEVudW0uUG9zdCxcclxuICAgICAgICAgICAgcGF0aDogZW5jb2RlKCcxL2Fuc3dlcnMvJXMvcHJlZGljdGlvbicsIGJhc2UuaW5kZXhOYW1lKSxcclxuICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgcXVlcnksXHJcbiAgICAgICAgICAgICAgICBxdWVyeUxhbmd1YWdlcyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2FjaGVhYmxlOiB0cnVlLFxyXG4gICAgICAgIH0sIHJlcXVlc3RPcHRpb25zKTtcclxuICAgIH07XHJcbn07XG5cbmNvbnN0IHNlYXJjaCA9IChiYXNlKSA9PiB7XHJcbiAgICByZXR1cm4gKHF1ZXJ5LCByZXF1ZXN0T3B0aW9ucykgPT4ge1xyXG4gICAgICAgIHJldHVybiBiYXNlLnRyYW5zcG9ydGVyLnJlYWQoe1xyXG4gICAgICAgICAgICBtZXRob2Q6IE1ldGhvZEVudW0uUG9zdCxcclxuICAgICAgICAgICAgcGF0aDogZW5jb2RlKCcxL2luZGV4ZXMvJXMvcXVlcnknLCBiYXNlLmluZGV4TmFtZSksXHJcbiAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgIHF1ZXJ5LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjYWNoZWFibGU6IHRydWUsXHJcbiAgICAgICAgfSwgcmVxdWVzdE9wdGlvbnMpO1xyXG4gICAgfTtcclxufTtcblxuY29uc3Qgc2VhcmNoRm9yRmFjZXRWYWx1ZXMgPSAoYmFzZSkgPT4ge1xyXG4gICAgcmV0dXJuIChmYWNldE5hbWUsIGZhY2V0UXVlcnksIHJlcXVlc3RPcHRpb25zKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGJhc2UudHJhbnNwb3J0ZXIucmVhZCh7XHJcbiAgICAgICAgICAgIG1ldGhvZDogTWV0aG9kRW51bS5Qb3N0LFxyXG4gICAgICAgICAgICBwYXRoOiBlbmNvZGUoJzEvaW5kZXhlcy8lcy9mYWNldHMvJXMvcXVlcnknLCBiYXNlLmluZGV4TmFtZSwgZmFjZXROYW1lKSxcclxuICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgZmFjZXRRdWVyeSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2FjaGVhYmxlOiB0cnVlLFxyXG4gICAgICAgIH0sIHJlcXVlc3RPcHRpb25zKTtcclxuICAgIH07XHJcbn07XG5cbmNvbnN0IExvZ0xldmVsRW51bSA9IHtcclxuICAgIERlYnVnOiAxLFxyXG4gICAgSW5mbzogMixcclxuICAgIEVycm9yOiAzLFxyXG59O1xuXG4vKiBlc2xpbnQgbm8tY29uc29sZTogMCAqL1xyXG5mdW5jdGlvbiBjcmVhdGVDb25zb2xlTG9nZ2VyKGxvZ0xldmVsKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGRlYnVnKG1lc3NhZ2UsIGFyZ3MpIHtcclxuICAgICAgICAgICAgaWYgKExvZ0xldmVsRW51bS5EZWJ1ZyA+PSBsb2dMZXZlbCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhtZXNzYWdlLCBhcmdzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpbmZvKG1lc3NhZ2UsIGFyZ3MpIHtcclxuICAgICAgICAgICAgaWYgKExvZ0xldmVsRW51bS5JbmZvID49IGxvZ0xldmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8obWVzc2FnZSwgYXJncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXJyb3IobWVzc2FnZSwgYXJncykge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UsIGFyZ3MpO1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cblxuY29uc3QgZ2V0UmVjb21tZW5kYXRpb25zID0gYmFzZSA9PiB7XHJcbiAgICByZXR1cm4gKHF1ZXJpZXMsIHJlcXVlc3RPcHRpb25zKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdHMgPSBxdWVyaWVzLm1hcChxdWVyeSA9PiAoe1xyXG4gICAgICAgICAgICAuLi5xdWVyeSxcclxuICAgICAgICAgICAgLy8gVGhlIGB0aHJlc2hvbGRgIHBhcmFtIGlzIHJlcXVpcmVkIGJ5IHRoZSBlbmRwb2ludCB0byBtYWtlIGl0IGVhc2llclxyXG4gICAgICAgICAgICAvLyB0byBwcm92aWRlIGEgZGVmYXVsdCB2YWx1ZSBsYXRlciwgc28gd2UgZGVmYXVsdCBpdCBpbiB0aGUgY2xpZW50XHJcbiAgICAgICAgICAgIC8vIHNvIHRoYXQgdXNlcnMgZG9uJ3QgaGF2ZSB0byBwcm92aWRlIGEgdmFsdWUuXHJcbiAgICAgICAgICAgIHRocmVzaG9sZDogcXVlcnkudGhyZXNob2xkIHx8IDAsXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHJldHVybiBiYXNlLnRyYW5zcG9ydGVyLnJlYWQoe1xyXG4gICAgICAgICAgICBtZXRob2Q6IE1ldGhvZEVudW0uUG9zdCxcclxuICAgICAgICAgICAgcGF0aDogJzEvaW5kZXhlcy8qL3JlY29tbWVuZGF0aW9ucycsXHJcbiAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RzLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjYWNoZWFibGU6IHRydWUsXHJcbiAgICAgICAgfSwgcmVxdWVzdE9wdGlvbnMpO1xyXG4gICAgfTtcclxufTtcblxuZnVuY3Rpb24gY3JlYXRlQnJvd3NlclhoclJlcXVlc3RlcigpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc2VuZChyZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZVJlcXVlc3RlciA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgICAgICAgICAgYmFzZVJlcXVlc3Rlci5vcGVuKHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LnVybCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhyZXF1ZXN0LmhlYWRlcnMpLmZvckVhY2goa2V5ID0+IGJhc2VSZXF1ZXN0ZXIuc2V0UmVxdWVzdEhlYWRlcihrZXksIHJlcXVlc3QuaGVhZGVyc1trZXldKSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjcmVhdGVUaW1lb3V0ID0gKHRpbWVvdXQsIGNvbnRlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VSZXF1ZXN0ZXIuYWJvcnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNUaW1lZE91dDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgdGltZW91dCAqIDEwMDApO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbm5lY3RUaW1lb3V0ID0gY3JlYXRlVGltZW91dChyZXF1ZXN0LmNvbm5lY3RUaW1lb3V0LCAnQ29ubmVjdGlvbiB0aW1lb3V0Jyk7XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuY3Rpb25hbC9uby1sZXRcclxuICAgICAgICAgICAgICAgIGxldCByZXNwb25zZVRpbWVvdXQ7XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuY3Rpb25hbC9pbW11dGFibGUtZGF0YVxyXG4gICAgICAgICAgICAgICAgYmFzZVJlcXVlc3Rlci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJhc2VSZXF1ZXN0ZXIucmVhZHlTdGF0ZSA+IGJhc2VSZXF1ZXN0ZXIuT1BFTkVEICYmIHJlc3BvbnNlVGltZW91dCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChjb25uZWN0VGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlVGltZW91dCA9IGNyZWF0ZVRpbWVvdXQocmVxdWVzdC5yZXNwb25zZVRpbWVvdXQsICdTb2NrZXQgdGltZW91dCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuY3Rpb25hbC9pbW11dGFibGUtZGF0YVxyXG4gICAgICAgICAgICAgICAgYmFzZVJlcXVlc3Rlci5vbmVycm9yID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJhc2VSZXF1ZXN0ZXIuc3RhdHVzID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChjb25uZWN0VGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChyZXNwb25zZVRpbWVvdXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGJhc2VSZXF1ZXN0ZXIucmVzcG9uc2VUZXh0IHx8ICdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogYmFzZVJlcXVlc3Rlci5zdGF0dXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1RpbWVkT3V0OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8vICBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuY3Rpb25hbC9pbW11dGFibGUtZGF0YVxyXG4gICAgICAgICAgICAgICAgYmFzZVJlcXVlc3Rlci5vbmxvYWQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNvbm5lY3RUaW1lb3V0KTtcclxuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocmVzcG9uc2VUaW1lb3V0KTtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogYmFzZVJlcXVlc3Rlci5yZXNwb25zZVRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogYmFzZVJlcXVlc3Rlci5zdGF0dXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVGltZWRPdXQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGJhc2VSZXF1ZXN0ZXIuc2VuZChyZXF1ZXN0LmRhdGEpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxuXG5mdW5jdGlvbiBhbGdvbGlhc2VhcmNoKGFwcElkLCBhcGlLZXksIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IGNvbW1vbk9wdGlvbnMgPSB7XHJcbiAgICAgICAgYXBwSWQsXHJcbiAgICAgICAgYXBpS2V5LFxyXG4gICAgICAgIHRpbWVvdXRzOiB7XHJcbiAgICAgICAgICAgIGNvbm5lY3Q6IDEsXHJcbiAgICAgICAgICAgIHJlYWQ6IDIsXHJcbiAgICAgICAgICAgIHdyaXRlOiAzMCxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlcXVlc3RlcjogY3JlYXRlQnJvd3NlclhoclJlcXVlc3RlcigpLFxyXG4gICAgICAgIGxvZ2dlcjogY3JlYXRlQ29uc29sZUxvZ2dlcihMb2dMZXZlbEVudW0uRXJyb3IpLFxyXG4gICAgICAgIHJlc3BvbnNlc0NhY2hlOiBjcmVhdGVJbk1lbW9yeUNhY2hlKCksXHJcbiAgICAgICAgcmVxdWVzdHNDYWNoZTogY3JlYXRlSW5NZW1vcnlDYWNoZSh7IHNlcmlhbGl6YWJsZTogZmFsc2UgfSksXHJcbiAgICAgICAgaG9zdHNDYWNoZTogY3JlYXRlRmFsbGJhY2thYmxlQ2FjaGUoe1xyXG4gICAgICAgICAgICBjYWNoZXM6IFtcclxuICAgICAgICAgICAgICAgIGNyZWF0ZUJyb3dzZXJMb2NhbFN0b3JhZ2VDYWNoZSh7IGtleTogYCR7dmVyc2lvbn0tJHthcHBJZH1gIH0pLFxyXG4gICAgICAgICAgICAgICAgY3JlYXRlSW5NZW1vcnlDYWNoZSgpLFxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIHVzZXJBZ2VudDogY3JlYXRlVXNlckFnZW50KHZlcnNpb24pLmFkZCh7XHJcbiAgICAgICAgICAgIHNlZ21lbnQ6ICdCcm93c2VyJyxcclxuICAgICAgICAgICAgdmVyc2lvbjogJ2xpdGUnLFxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIGF1dGhNb2RlOiBBdXRoTW9kZS5XaXRoaW5RdWVyeVBhcmFtZXRlcnMsXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGNyZWF0ZVNlYXJjaENsaWVudCh7XHJcbiAgICAgICAgLi4uY29tbW9uT3B0aW9ucyxcclxuICAgICAgICAuLi5vcHRpb25zLFxyXG4gICAgICAgIG1ldGhvZHM6IHtcclxuICAgICAgICAgICAgc2VhcmNoOiBtdWx0aXBsZVF1ZXJpZXMsXHJcbiAgICAgICAgICAgIHNlYXJjaEZvckZhY2V0VmFsdWVzOiBtdWx0aXBsZVNlYXJjaEZvckZhY2V0VmFsdWVzLFxyXG4gICAgICAgICAgICBtdWx0aXBsZVF1ZXJpZXMsXHJcbiAgICAgICAgICAgIG11bHRpcGxlU2VhcmNoRm9yRmFjZXRWYWx1ZXMsXHJcbiAgICAgICAgICAgIGN1c3RvbVJlcXVlc3QsXHJcbiAgICAgICAgICAgIGluaXRJbmRleDogYmFzZSA9PiAoaW5kZXhOYW1lKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5pdEluZGV4KGJhc2UpKGluZGV4TmFtZSwge1xyXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZHM6IHsgc2VhcmNoLCBzZWFyY2hGb3JGYWNldFZhbHVlcywgZmluZEFuc3dlcnMgfSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBnZXRSZWNvbW1lbmRhdGlvbnMsXHJcbiAgICAgICAgfSxcclxuICAgIH0pO1xyXG59XHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jdGlvbmFsL2ltbXV0YWJsZS1kYXRhXHJcbmFsZ29saWFzZWFyY2gudmVyc2lvbiA9IHZlcnNpb247XG5cbmV4cG9ydCBkZWZhdWx0IGFsZ29saWFzZWFyY2g7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/algoliasearch/dist/algoliasearch-lite.esm.browser.js\n");

/***/ })

};
;